<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>IBM Salesforce Context Telemetry</title>
	<link rel="icon" type="image/svg+xml" sizes="any" href="/resources/favicon.svg">
	<link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon.png">
	<link href="/css/output.css" rel="stylesheet">
	<link rel="stylesheet" href="/vendor/fontawesome/css/all.min.css">
	<link rel="stylesheet" href="/vendor/fontawesome/css/v4-shims.min.css">
	<script>
		// Apply theme immediately before page render to prevent flash
		(function() {
			const savedTheme = localStorage.getItem('theme');
			const theme = savedTheme || 'dark';
			if (theme === 'dark') {
				document.documentElement.classList.add('dark');
			}
		})();
	</script>
	<style>
		:root {
			/* Light mode colors - matching Laravel Log Viewer */
			--bg-primary: #ffffff;
			--bg-secondary: #fafafa;
			--bg-sidebar: #fafafa;
			--bg-table-header: #f4f4f5;
			--text-primary: #18181b;
			--text-secondary: #52525b;
			--text-muted: #a1a1aa;
			--border-color: #e4e4e7;
			--hover-bg: #f4f4f5;

			/* Level colors - matching Laravel Log Viewer */
			--level-success: #10b981;
			--level-success-bg: #ecfdf5;
			--level-success-hover: #d1fae5;
			--level-info: #0ea5e9;
			--level-info-bg: #f0f9ff;
			--level-info-hover: #e0f2fe;
			--level-warning: #f59e0b;
			--level-warning-bg: #fffbeb;
			--level-warning-hover: #fef3c7;
			--level-error: #ef4444;
			--level-error-bg: #fef2f2;
			--level-error-hover: #fee2e2;
			--level-debug: #0ea5e9;

			/* Brand color (sky) */
			--brand-500: #0ea5e9;
			--brand-600: #0284c7;
			--brand-700: #0369a1;
			--brand-800: #075985;
			--brand-900: #0c4a6e;
			--sidebar-width: 310px;
		}

		html.dark {
			/* Dark mode colors - matching Laravel Log Viewer */
			--bg-primary: #27272a;
			--bg-secondary: #18181b;
			--bg-sidebar: #27272a;
			--bg-table-header: #18181b;
			--text-primary: #e4e4e7;
			--text-secondary: #a1a1aa;
			--text-muted: #71717a;
			--border-color: #3f3f46;
			--hover-bg: #3f3f46;

			/* Dark mode level colors */
			--level-success: #10b981;
			--level-success-bg: rgba(6, 78, 59, 0.4);
			--level-success-hover: rgba(6, 78, 59, 0.75);
			--level-info: #0ea5e9;
			--level-info-bg: rgba(12, 74, 110, 0.4);
			--level-info-hover: rgba(12, 74, 110, 0.75);
			--level-warning: #fbbf24;
			--level-warning-bg: rgba(120, 53, 15, 0.4);
			--level-warning-hover: rgba(120, 53, 15, 0.75);
			--level-error: #fb7185;
			--level-error-bg: rgba(136, 19, 55, 0.4);
			--level-error-hover: rgba(136, 19, 55, 0.75);

			/* Dark mode brand */
			--brand-500: #0ea5e9;
			--brand-600: #0284c7;
			--brand-700: #0369a1;
			--brand-800: #075985;
			--brand-900: #0c4a6e;
		}

		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		/* Prevent flash of unstyled content - hide body until theme is applied */
		html:not(.dark) body {
			visibility: hidden;
		}

		html.dark body {
			visibility: visible;
		}

		body {
			font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
			font-weight: 300;
			background: linear-gradient(45deg, #a9c9ff, #f1d1ff);
			min-height: 100vh;
			padding: 20px 12px;
			position: relative;
		}

		body::before {
			content: '';
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background:
				radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.3) 0%, transparent 50%),
				radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
			pointer-events: none;
			z-index: 0;
		}

		html.dark {
			color-scheme: dark;
		}

		.main-container {
			position: relative;
			z-index: 10;
			margin: 0 auto;
			width: calc(100vw - 58px);
			max-width: none;
			background: #f4f4f5;
			border-radius: 16px;
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
			overflow: hidden;
			display: flex;
			flex-direction: column;
			height: calc(100vh - 50px);
		}

		html[data-runtime="electron"] body {
			padding: 0;
		}

		html[data-runtime="electron"] .main-container {
			border-radius: 0;
		}

		html.dark .main-container {
			background: #27272a;
		}


		.log-viewer-title {
			font-size: 1.25rem;
			line-height: 1.75rem;
			font-weight: 600;
			color: #10b981;
			display: flex;
			align-items: center;
			gap: 8px;
			transition: opacity 0.2s ease;
		}

		.log-viewer-title:hover {
			opacity: 0.8;
		}

		html.dark .log-viewer-title {
			color: #10b981;
		}


		.back-link {
			font-size: 0.875rem;
			line-height: 1.25rem;
			color: #52525b;
			text-decoration: none;
			margin-left: 0;
			transition: color 0.2s ease;
		}

		html.dark .back-link {
			color: #a1a1aa;
		}

		.back-link:hover {
			color: #18181b;
		}

		html.dark .back-link:hover {
			color: #e4e4e7;
		}


		.level-filters {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}

		.level-filter-btn {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			padding: 4px 10px;
			border: 1px solid;
			border-radius: 6px;
			font-size: 0.64375rem;
			line-height: 1rem;
			font-weight: 800;
			text-transform: uppercase;
			cursor: pointer;
			transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
			position: relative;
			height: 100%;
			min-height: 28px;
		}

		.level-filter-btn input[type="checkbox"] {
			appearance: none;
			-webkit-appearance: none;
			-moz-appearance: none;
			width: 14px;
			height: 14px;
			margin-right: 2px;
			cursor: pointer;
			background-color: white;
			border: 1px solid #d1d5db;
			border-radius: 3px;
			position: relative;
			flex-shrink: 0;
		}

		.level-filter-btn input[type="checkbox"]:checked {
			background-color: white;
			border-color: #6b7280;
		}

		.level-filter-btn input[type="checkbox"]:checked::after {
			content: '';
			position: absolute;
			left: 4px;
			top: 1px;
			width: 5px;
			height: 9px;
			border: solid #6b7280;
			border-width: 0 2px 2px 0;
			transform: rotate(45deg);
		}

		/* Checkbox mark color matches button background when active */
		.level-filter-btn.level-debug.active input[type="checkbox"]:checked::after {
			border-color: #8e81ea;
		}

		.level-filter-btn.level-info.active input[type="checkbox"]:checked::after {
			border-color: #2195cf;
		}

		.level-filter-btn.level-warning.active input[type="checkbox"]:checked::after {
			border-color: #DB9139;
		}

		.level-filter-btn.level-error.active input[type="checkbox"]:checked::after {
			border-color: #ea6280;
		}

		.level-filter-btn.level-success.active input[type="checkbox"]:checked::after {
			border-color: #065f46;
		}

		html.dark .level-filter-btn input[type="checkbox"] {
			background-color: white;
			border-color: #9ca3af;
		}

		html.dark .level-filter-btn input[type="checkbox"]:checked {
			background-color: white;
			border-color: #6b7280;
		}

		html.dark .level-filter-btn input[type="checkbox"]:checked::after {
			border-color: #6b7280;
		}

		html.dark .level-filter-btn.level-debug.active input[type="checkbox"]:checked::after {
			border-color: #8e81ea;
		}

		html.dark .level-filter-btn.level-info.active input[type="checkbox"]:checked::after {
			border-color: #2195cf;
		}

		html.dark .level-filter-btn.level-warning.active input[type="checkbox"]:checked::after {
			border-color: #DB9139;
		}

		html.dark .level-filter-btn.level-error.active input[type="checkbox"]:checked::after {
			border-color: #ea6280;
		}

		html.dark .level-filter-btn.level-success.active input[type="checkbox"]:checked::after {
			border-color: #065f46;
		}

		.level-filter-btn.level-debug {
			background: #f0f9ff;
			border-color: #dbeafe;
			color: #0c4a6e;
		}

		html.dark .level-filter-btn.level-debug {
			background: rgba(12, 74, 110, 0.25);
			border-color: #075985;
			color: #7dd3fc;
		}

		.level-filter-btn.level-info {
			background: #f0f9ff;
			border-color: #dbeafe;
			color: #0c4a6e;
		}

		html.dark .level-filter-btn.level-info {
			background: rgba(12, 74, 110, 0.25);
			border-color: #075985;
			color: #7dd3fc;
		}

		.level-filter-btn.level-warning {
			background: #fffbeb;
			border-color: #fef3c7;
			color: #92400e;
		}

		html.dark .level-filter-btn.level-warning {
			background: rgba(120, 53, 15, 0.25);
			border-color: #92400e;
			color: #fbbf24;
		}

		.level-filter-btn.level-error {
			background: #fef2f2;
			border-color: #fee2e2;
			color: #991b1b;
		}

		html.dark .level-filter-btn.level-error {
			background: rgba(136, 19, 55, 0.25);
			border-color: #9f1239;
			color: #fb7185;
		}

		.level-filter-btn.level-success {
			background: #d1fae5;
			border-color: #a7f3d0;
			color: #065f46;
		}

		html.dark .level-filter-btn.level-success {
			background: rgba(6, 78, 59, 0.3);
			border-color: #065f46;
			color: #10b981;
		}

		.level-filter-btn:hover {
			opacity: 1;
		}

		.level-filter-btn.level-debug:hover {
			background: #e9d5ff;
		}

		.level-filter-btn.level-info:hover {
			background: var(--level-info-hover);
		}

		.level-filter-btn.level-warning:hover {
			background: var(--level-warning-hover);
		}

		.level-filter-btn.level-error:hover {
			background: var(--level-error-hover);
		}

		.level-filter-btn.level-success:hover {
			background: var(--level-success-hover);
		}

		.level-filter-btn.active {
			color: white;
		}

		.level-filter-btn.level-debug.active {
			background: #8e81ea;
			border-color: #8e81ea;
			color: white;
		}

		.level-filter-btn.level-info.active {
			background: #2195cf;
			border-color: #2195cf;
			color: white;
		}

		html.dark .level-filter-btn.level-debug.active {
			background: #8e81ea;
			border-color: #8e81ea;
			color: white;
		}

		html.dark .level-filter-btn.level-info.active {
			background: #2195cf;
			border-color: #2195cf;
			color: white;
		}

		.level-filter-btn.level-warning.active {
			background: #DB9139;
			border-color: #DB9139;
			color: white;
		}

		html.dark .level-filter-btn.level-warning.active {
			background: #DB9139;
			border-color: #DB9139;
			color: white;
		}

		.level-filter-btn.level-error.active {
			background: #ea6280;
			border-color: #ea6280;
			color: white;
		}

		html.dark .level-filter-btn.level-error.active {
			background: #ea6280;
			border-color: #ea6280;
			color: white;
		}

		.level-filter-btn.level-success.active {
			background: #a7f3d0;
			border-color: #6ee7b7;
			color: #065f46;
		}

		html.dark .level-filter-btn.level-success.active {
			background: #a7f3d0;
			border-color: #6ee7b7;
			color: #065f46;
		}

		.level-filter-btn .level-icon {
			font-size: 0.875rem;
			line-height: 1.25rem;
		}

		.level-filter-btn .level-count {
			background: rgba(0, 0, 0, 0.08);
			padding: 1px 5px;
			border-radius: 10px;
			font-size: 0.6rem;
			line-height: 1rem;
			font-weight: 700;
			margin-left: 2px;
			transition: background-color 0.2s ease, transform 0.2s ease;
		}

		.level-filter-btn span:not(.level-count) {
			font-size: inherit;
			line-height: inherit;
		}

		html.dark .level-filter-btn .level-count {
			background: rgba(255, 255, 255, 0.15);
		}

		.level-filter-btn.active .level-count {
			background: rgba(255, 255, 255, 0.3);
		}

		html.dark .level-filter-btn.active .level-count {
			background: rgba(255, 255, 255, 0.3);
		}

		.level-filter-btn:hover .level-count {
			transform: scale(1.05);
		}

		.search-controls {
			display: flex;
			align-items: center;
			gap: 0;
		}

		.search-controls .search-input {
			margin-right: 10px;
		}

		.icon-buttons-group {
			display: flex;
			align-items: center;
			gap: 0;
			border-radius: 8px;
			position: relative;
		}

		.icon-buttons-group::before {
			content: '';
			position: absolute;
			top: -2px;
			left: -2px;
			right: -2px;
			bottom: -2px;
			border: 2px solid transparent;
			border-radius: 8px;
			pointer-events: none;
			z-index: 10;
			transition: border-color 0.2s ease;
		}

		.icon-buttons-group::after {
			content: '';
			position: absolute;
			top: 0;
			left: var(--hover-left, 0);
			width: 40px;
			height: 40px;
			background: var(--hover-bg);
			border-radius: 0;
			pointer-events: none;
			z-index: 1;
			opacity: 0;
			transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.15s ease, border-radius 0.3s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s cubic-bezier(0.4, 0, 0.2, 1);
		}

		.icon-buttons-group.no-transition::after {
			transition: opacity 0.15s ease, border-radius 0.3s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
		}

		.icon-buttons-group:has(.icon-btn:hover)::before {
			border-color: var(--border-color);
		}

		.icon-buttons-group:has(.icon-btn:nth-child(1):hover) {
			--hover-left: 0;
			--last-hover-left: 0;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(1):hover)::after {
			left: var(--hover-left);
			opacity: 1;
			border-top-left-radius: 8px;
			border-bottom-left-radius: 8px;
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(2):hover) {
			--hover-left: 40px;
			--last-hover-left: 40px;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(2):hover)::after {
			left: var(--hover-left);
			opacity: 1;
			border-radius: 0;
			background: #fee2e2;
		}

		html.dark .icon-buttons-group:has(.icon-btn:nth-child(2):hover)::after {
			background: rgba(220, 38, 38, 0.2);
		}

		.icon-buttons-group:has(.icon-btn:nth-child(3):hover) {
			--hover-left: 80px;
			--last-hover-left: 80px;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(3):hover)::after {
			left: var(--hover-left);
			opacity: 1;
			border-radius: 0;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(4):hover) {
			--hover-left: 120px;
			--last-hover-left: 120px;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(4):hover)::after {
			left: var(--hover-left);
			opacity: 1;
			border-radius: 0;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(5):hover) {
			--hover-left: 160px;
			--last-hover-left: 160px;
		}

		.icon-buttons-group:has(.icon-btn:nth-child(5):hover)::after {
			left: var(--hover-left);
			opacity: 1;
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
			border-top-right-radius: 8px;
			border-bottom-right-radius: 8px;
		}

		.icon-buttons-group .icon-btn {
			border-radius: 0;
			position: relative;
			z-index: 2;
			background: transparent !important;
		}

		.icon-buttons-group .icon-btn:hover {
			transform: scale(1.05);
			background: transparent !important;
		}

		.icon-buttons-group .icon-btn:hover:not(.delete-all-btn):not(.notification-toggle.active) {
			background: transparent !important;
		}

		.icon-buttons-group .icon-btn:first-of-type {
			border-top-left-radius: 8px;
			border-bottom-left-radius: 8px;
		}

		.icon-buttons-group .icon-btn:last-of-type {
			border-top-right-radius: 8px;
			border-bottom-right-radius: 8px;
		}

		.table-controls {
			padding: 0 16px;
			display: flex;
			justify-content: flex-end;
			align-items: center;
			flex-shrink: 0;
		}

		.table-controls-right {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.search-input {
			padding: 6px 12px;
			border: 1px solid #d4d4d8;
			border-radius: 6px;
			font-size: 0.875rem;
			line-height: 1.25rem;
			width: 250px;
			background: white;
			color: #18181b;
			transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
		}

		html.dark .search-input {
			border-color: #52525b;
			background: #27272a;
			color: #f4f4f5;
		}

		.search-input::placeholder {
			color: #a1a1aa;
		}

		html.dark .search-input::placeholder {
			color: #71717a;
		}

		.search-input:focus {
			outline: none;
			border-color: #0ea5e9;
			box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
		}

		html.dark .search-input:focus {
			border-color: #0369a1;
			box-shadow: 0 0 0 3px rgba(3, 105, 161, 0.3);
		}

		.control-select {
			padding: 6px 24px 6px 8px;
			border: none;
			border-radius: 0;
			font-size: 0.875rem;
			line-height: 1.25rem;
			background: transparent;
			color: #a1a1aa;
			cursor: pointer;
			transition: color 0.2s ease, opacity 0.2s ease;
			appearance: none;
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%23a1a1aa' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
			background-repeat: no-repeat;
			background-position: right 4px center;
			background-size: 16px;
			padding-right: 24px;
		}

		.control-select:hover {
			opacity: 0.8;
		}

		.control-select:focus {
			outline: none;
			opacity: 1;
		}

		html.dark .control-select {
			color: #71717a;
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%2371717a' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
		}

		.control-select:hover {
			color: #52525b;
		}

		html.dark .control-select:hover {
			color: #a1a1aa;
		}

		.control-select:focus {
			outline: none;
			color: #52525b;
		}

		html.dark .control-select:focus {
			color: #a1a1aa;
		}

		.icon-btn {
			width: 40px;
			height: 40px;
			border: none;
			border-radius: 8px;
			background: var(--bg-table-header);
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.125rem;
			line-height: 1.75rem;
			transition: background-color 0.2s ease, color 0.2s ease, transform 0.15s ease;
			color: var(--text-secondary);
		}

		.icon-btn:hover {
			transform: scale(1.1);
		}

		.icon-btn:active {
			transform: scale(0.95);
		}

		.icon-btn.notification-toggle.active {
			background: var(--brand-600);
			color: white;
		}

		html.dark .icon-btn.notification-toggle.active {
			background: var(--brand-700);
			color: white;
		}

		html.dark .icon-btn {
			background: var(--bg-table-header);
			color: var(--text-secondary);
		}

		.icon-btn:hover:not(.delete-all-btn):not(.notification-toggle.active) {
			background: var(--hover-bg);
			color: var(--text-primary);
		}

		html.dark .icon-btn:hover:not(.delete-all-btn):not(.notification-toggle.active) {
			background: var(--hover-bg);
			color: var(--text-primary);
		}

		.delete-all-btn {
			background: var(--bg-table-header);
		}

		.delete-all-btn:hover {
			background: #fee2e2;
			color: #dc2626;
			transform: scale(1.1);
		}

		html.dark .delete-all-btn {
			background: var(--bg-table-header);
		}

		html.dark .delete-all-btn:hover {
			background: rgba(220, 38, 38, 0.2);
			color: #c64545;
		}

		.global-error-banner {
			display: none;
			margin: 10px 14px 0;
			padding: 10px 14px;
			border-radius: 10px;
			background: #fee2e2;
			border: 1px solid #fecaca;
			color: #7f1d1d;
			font-size: 0.875rem;
			font-weight: 600;
			box-shadow: 0 10px 30px rgba(190, 18, 60, 0.08);
			line-height: 1.4;
			display: flex;
			flex-direction: column;
			gap: 4px;
		}

		html.dark .global-error-banner {
			background: rgba(127, 29, 29, 0.3);
			border-color: rgba(248, 113, 113, 0.4);
			color: #fecaca;
		}

		.global-error-banner.hidden {
			display: none;
		}

		.content-wrapper {
			display: flex;
			flex: 1;
			overflow: hidden;
			gap: 0;
			padding: 0 16px;
		}

		html.dark .content-wrapper {
			background: #19181a;
		}

		.sidebar {
			width: var(--sidebar-width);
			background: transparent;
			border-right: none;
			overflow: hidden;
			display: flex;
			flex-direction: column;
			flex-shrink: 0;
			align-items: stretch;
		}

		html.dark .sidebar {
			background: #19181a;
		}

		.sidebar-resizer {
			width: 10px;
			cursor: col-resize;
			position: relative;
			z-index: 10;
			margin: 0;
		}

		.sidebar-resizer::after {
			content: '';
			position: absolute;
			top: 24px;
			bottom: 24px;
			left: 50%;
			transform: translateX(-50%);
			width: 3px;
			background: transparent;
			border-radius: 999px;
			transition: background 0.15s ease;
		}

		.sidebar-resizer:hover::after,
		.sidebar-resizer:focus-visible::after,
		body.sidebar-resizing .sidebar-resizer::after {
			background: rgba(14, 165, 233, 0.6);
		}

		body.sidebar-resizing,
		body.sidebar-resizing * {
			user-select: none !important;
			cursor: col-resize !important;
		}

		.sidebar-header {
			padding: 20px 12px;
			border-bottom: none;
			flex-shrink: 0;
		}

		@media (min-width: 768px) {
			.sidebar-header {
				padding: 20px;
			}
		}

		.sidebar-content {
			flex: 1;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			padding: 0 12px 20px 12px;
			padding-top: 20px;
		}

		@media (min-width: 768px) {
			.sidebar-content {
				padding: 0 20px 20px 20px;
				padding-top: 20px;
			}
		}

		.all-sessions-container {
			flex-shrink: 0;
			margin-bottom: 0;
		}

		.all-sessions-container .server-item:last-child {
			margin-bottom: 6px;
		}

		.sessions-scrollable {
			flex: 1;
			overflow-y: auto;
			overflow-x: hidden;
			margin-right: -14px;
			padding-right: 6px;
		}

		.sessions-scrollable .server-list {
			padding-right: 0;
		}


		.sidebar-title {
			font-size: 0.75rem;
			line-height: 1rem;
			font-weight: 300;
			color: var(--text-muted);
			margin-bottom: 12px;
			margin-top: 0;
			padding-top: 0;
			text-transform: uppercase;
			letter-spacing: 0.07em;
		}

		.server-list {
			list-style: none;
		}

		.server-item {
			padding: 10px 4px 10px 12px;
			margin-bottom: 6px;
			border-radius: 0;
			cursor: pointer;
			transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
			display: flex;
			align-items: center;
			gap: 8px;
			background: white;
			border: 2px solid transparent;
			position: relative;
			min-height: 48px;
			min-width: 0;
		}

		.server-item-left {
			display: flex;
			align-items: center;
			flex: 1;
			min-width: 0;
			overflow: hidden;
		}

		.server-item-right {
			display: flex;
			align-items: center;
			gap: 2px;
			flex-shrink: 0;
		}

		.server-item:hover .server-item-actions {
			z-index: 1001;
		}

		.server-item:hover {
			transform: translateX(2px);
		}

		.server-item:active {
			transform: translateX(0);
		}

		html.dark .server-item {
			background: #27272c;
		}

		.server-item:hover {
			background: #e0f2fe;
			border-color: #0284c7;
		}

		html.dark .server-item:hover {
			background: #27272c;
			border-color: #0369a1;
			box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.2);
		}

		.server-item.active {
			background: #bae6fd;
			border-color: transparent;
		}

		html.dark .server-item.active {
			background: rgba(14, 165, 233, 0.18);
			border-color: transparent;
		}

		.server-item.active .server-name {
			color: #18181b;
			font-weight: 600;
		}

		html.dark .server-item.active .server-name {
			color: #e4e4e7;
		}

		.server-item.keyboard-selected {
			background: var(--hover-bg);
			outline: 2px solid var(--brand-500);
			outline-offset: -2px;
		}

		html.dark .server-item.keyboard-selected {
			background: var(--hover-bg);
		}

		.server-name {
			font-size: 0.8125rem;
			line-height: 1.15rem;
			color: #18181b;
			flex: 1;
			min-width: 0;
			font-weight: 500;
			transition: color 0.2s ease, font-weight 0.2s ease;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		html.dark .server-name {
			color: #e4e4e7;
		}

		.session-date {
			font-weight: 400;
			color: inherit;
		}

		.session-user {
			font-weight: 300;
			color: rgba(24, 24, 27, 0.75);
		}

		html.dark .session-user {
			color: rgba(228, 228, 231, 0.7);
		}

		.server-item.active .server-name {
			font-weight: 600;
		}

		.server-size {
			background: rgba(0, 0, 0, 0.08);
			padding: 1px 5px;
			border-radius: 10px;
			font-size: 0.6rem;
			line-height: 1rem;
			font-weight: 700;
			color: #52525b;
			flex-shrink: 0;
			transition: background-color 0.2s ease, transform 0.2s ease;
		}

		html.dark .server-size {
			background: rgba(255, 255, 255, 0.15);
			color: #a1a1aa;
		}

		.server-item:hover .server-size {
			transform: scale(1.05);
		}

		.server-item-actions {
			position: relative;
			z-index: 10;
			display: flex;
			align-items: center;
			justify-content: flex-end;
			min-width: 2px;
			flex-shrink: 0;
		}

		.server-item-actions .actions-dropdown {
			z-index: 1000;
		}

		.server-item .server-item-actions .actions-dropdown.show {
			z-index: 10000;
		}

		.server-item.dropdown-open {
			z-index: 100;
		}

		.session-active-indicator {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background-color: #10b981;
			margin-right: 8px;
			flex-shrink: 0;
		}

		html.dark .session-active-indicator {
			background-color: #10b981;
		}

		.main-content {
			flex: 1;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			background: #f4f4f5;
			position: relative;
			min-width: 0;
		}

		html.dark .main-content {
			background: #19181a;
		}

		.main-content-header {
			padding: 20px 16px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 16px;
			border-bottom: none;
			flex-shrink: 0;
		}

		.main-content-body {
			flex: 1;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			min-height: 0;
		}

		.activity-table-layout {
			flex: 1;
			display: flex;
			flex-direction: column;
			min-height: 0;
		}

		.logs-panel {
			flex: 1;
			display: flex;
			flex-direction: column;
			min-height: 0;
		}

		.session-activity-card {
			background: var(--bg-secondary);
			border: 1px solid var(--border-color);
			border-radius: 14px;
			padding: 16px 20px 12px 20px;
			margin: 0 16px;
			box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
			transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
			display: flex;
			flex-direction: column;
			min-height: 190px;
			height: 240px;
		}

		.session-activity-card.hidden {
			display: none;
		}

		.session-activity-header {
			display: flex;
			align-items: flex-start;
			justify-content: space-between;
			gap: 16px;
			margin-bottom: 10px;
		}

		.session-activity-header .label {
			font-size: 0.75rem;
			letter-spacing: 0.07em;
			text-transform: uppercase;
			color: var(--text-muted);
			margin-bottom: 4px;
			font-weight: 300;
		}

		.session-activity-header .subtitle {
			font-size: 0.95rem;
			color: var(--text-primary);
			font-weight: 500;
			display: none;
		}

		.date-nav-btn {
			background: transparent;
			border: none;
			cursor: pointer;
			padding: 4px 8px;
			border-radius: 4px;
			color: var(--text-secondary);
			font-size: 0.875rem;
			transition: background-color 0.2s ease, color 0.2s ease;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.date-nav-btn:hover {
			background: var(--hover-bg);
			color: var(--text-primary);
		}

		.date-nav-btn:disabled {
			opacity: 0.3;
			cursor: not-allowed;
		}

		.date-nav-btn:disabled:hover {
			background: transparent;
			color: var(--text-secondary);
		}

		.session-activity-legend-wrapper {
			position: relative;
			display: flex;
			align-items: center;
			justify-content: flex-end;
		}

		.session-activity-legend-toggle {
			display: inline-flex;
			align-items: center;
			gap: 8px;
			padding: 4px 10px;
			border-radius: 999px;
			border: none;
			background: rgba(255, 255, 255, 0.85);
			color: var(--text-secondary);
			font-size: 0.75rem;
			line-height: 1rem;
			cursor: default;
			box-shadow: 0 8px 18px rgba(0, 0, 0, 0.06);
			backdrop-filter: blur(8px);
			-webkit-backdrop-filter: blur(8px);
			transition: background-color 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease, transform 0.12s ease;
		}

		html.dark .session-activity-legend-toggle {
			background: rgba(24, 24, 27, 0.85);
			color: var(--text-secondary);
		}

		.session-activity-legend-toggle-dot {
			width: 8px;
			height: 8px;
			border-radius: 999px;
			background: #38bdf8;
			box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.25);
		}

		.session-activity-legend-toggle-image {
			width: 18px;
			height: 18px;
			display: inline-block;
			object-fit: contain;
			flex-shrink: 0;
		}

		html.dark .session-activity-legend-toggle-dot {
			box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.35);
		}

		.session-activity-legend-wrapper:hover .session-activity-legend-toggle,
		.session-activity-legend-wrapper:focus-within .session-activity-legend-toggle,
		.session-activity-legend-wrapper.is-open .session-activity-legend-toggle {
			background: var(--bg-primary);
			border-color: var(--brand-500);
			box-shadow: 0 10px 24px rgba(0, 0, 0, 0.09);
			transform: translateY(-1px);
		}

		.session-activity-legend {
			position: absolute;
			top: 120%;
			right: 0;
			z-index: 30;
			min-width: 280px;
			max-width: 450px;
			max-height: 260px;
			padding: 10px 12px;
			border-radius: 10px;
			background: var(--bg-primary);
			border: 1px solid var(--border-color);
			box-shadow: 0 18px 40px rgba(0, 0, 0, 0.18);
			display: flex;
			flex-direction: column;
			gap: 8px;
			font-size: 0.8rem;
			color: var(--text-secondary);
			overflow-y: auto;
			opacity: 0;
			pointer-events: none;
			transform: translateY(6px);
			transition: opacity 0.15s ease, transform 0.15s ease;
		}

		.session-activity-legend-wrapper:hover .session-activity-legend,
		.session-activity-legend-wrapper:focus-within .session-activity-legend,
		.session-activity-legend-wrapper.is-open .session-activity-legend {
			opacity: 1;
			pointer-events: auto;
			transform: translateY(0);
		}

		.session-activity-legend .legend-item {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			white-space: nowrap;
		}

		.session-activity-legend .legend-item span:last-child {
			white-space: nowrap;
		}

		.session-activity-legend .legend-dot {
			width: 10px;
			height: 10px;
			border-radius: 999px;
			display: inline-block;
		}

		#sessionActivityChart {
			width: 100%;
			flex: 1;
			min-height: 0;
		}

		.horizontal-resizer {
			height: 12px;
			margin: 6px 16px;
			position: relative;
			cursor: row-resize;
			flex-shrink: 0;
		}

		.horizontal-resizer::before {
			content: '';
			position: absolute;
			left: 0;
			right: 0;
			top: -6px;
			bottom: -6px;
		}

		.horizontal-resizer::after {
			content: '';
			position: absolute;
			left: 24px;
			right: 24px;
			top: 50%;
			transform: translateY(-50%);
			height: 3px;
			border-radius: 999px;
			background: transparent;
			transition: background 0.15s ease;
		}

		.horizontal-resizer:hover::after,
		.horizontal-resizer:focus-visible::after,
		body.activity-resizing .horizontal-resizer::after {
			background: rgba(14, 165, 233, 0.6);
		}

		.horizontal-resizer.hidden {
			display: none;
		}

		.logs-table-container {
			flex: 1;
			overflow: hidden;
			position: relative;
			min-height: 0;
			display: flex;
			flex-direction: column;
		}

		.logs-table-container > div:last-child {
			flex: 1;
			overflow-y: auto;
			min-height: 0;
		}

		.logs-table {
			width: 100%;
			border-collapse: separate;
			border-spacing: 0;
			font-size: 0.875rem;
			line-height: 1.25rem;
			border: none;
			border-radius: 0;
			overflow: visible;
		}

		.logs-table thead {
			display: table-header-group;
			position: sticky;
			top: 0;
			z-index: 10;
			background: #f4f4f5;
		}

		html.dark .logs-table thead {
			background: #19181a;
		}

		.logs-table tbody {
			display: table-row-group;
		}

		.logs-table th {
			padding: 12px 4px;
			text-align: left;
			font-weight: 400;
			color: var(--text-muted);
			border-bottom: 2px solid #f4f4f5;
			font-size: 0.75rem;
			line-height: 1;
			letter-spacing: 0.07em;
			text-transform: uppercase;
		}

		html.dark .logs-table th {
			color: var(--text-muted);
			border-bottom: 2px solid #19181a;
		}

		.logs-table td {
			padding: 8px 4px;
			border-bottom: 2px solid #f4f4f5;
			color: #18181b;
			font-size: 0.75rem;
			line-height: 1.2;
			transition: background-color 0.15s ease;
		}

		html.dark .logs-table td {
			border-bottom: 2px solid #19181a;
		}

		.logs-table tbody tr {
			transition: background-color 0.15s ease;
			background: white;
			cursor: pointer;
		}

		html.dark .logs-table tbody tr {
			background: #1f1f23;
		}

		.logs-table tbody tr:hover {
			background-color: rgba(14, 165, 233, 0.05);
		}

		html.dark .logs-table tbody tr:hover {
			background-color: rgba(14, 165, 233, 0.15);
			box-shadow: none;
		}

		.logs-table tbody tr.keyboard-selected {
			background-color: rgba(14, 165, 233, 0.1);
			outline: 2px solid var(--brand-500);
			outline-offset: -2px;
		}

		html.dark .logs-table tbody tr.keyboard-selected {
			background-color: rgba(14, 165, 233, 0.25);
		}
		/* Level-specific row hover colors */
		.logs-table tbody tr.log-item-success:hover {
			background-color: rgba(16, 185, 129, 0.05);
		}

		html.dark .logs-table tbody tr.log-item-success:hover {
			background-color: rgba(16, 185, 129, 0.2);
			box-shadow: none;
		}

		.logs-table tbody tr.log-item-info:hover {
			background-color: rgba(14, 165, 233, 0.05);
		}

		html.dark .logs-table tbody tr.log-item-info:hover {
			background-color: rgba(14, 165, 233, 0.2);
			box-shadow: none;
		}

		.logs-table tbody tr.log-item-warning:hover {
			background-color: rgba(245, 158, 11, 0.05);
		}

		html.dark .logs-table tbody tr.log-item-warning:hover {
			background-color: rgba(245, 158, 11, 0.2);
			box-shadow: none;
		}

		.logs-table tbody tr.log-item-error:hover {
			background-color: rgba(239, 68, 68, 0.05);
		}

		html.dark .logs-table tbody tr.log-item-error:hover {
			background-color: rgba(239, 68, 68, 0.2);
			box-shadow: none;
		}

		.level-badge {
			display: inline-flex;
			align-items: center;
			justify-content: flex-start;
			gap: 6px;
			padding: 4px 10px;
			border-radius: 6px;
			transition: opacity 0.2s ease, transform 0.15s ease;
			font-size: 0.64375rem;
			line-height: 1rem;
			font-weight: 800;
			text-transform: uppercase;
			width: auto;
			min-width: fit-content;
			white-space: nowrap;
			box-sizing: border-box;
		}

		.level-badge.debug {
			background: #8e81ea;
			color: white;
		}

		.level-badge.info {
			background: #2195cf;
			color: white;
		}

		.level-badge.warning {
			background: #DB9139;
			color: white;
		}

		.level-badge.error {
			background: #ea6280;
			color: white;
		}

		.level-badge.success {
			background: #a7f3d0;
			color: #ffffff;
		}

		.level-badge-icon {
			font-size: 0.75rem;
			line-height: 1rem;
		}

		.logs-table th.time-column,
		.log-time {
			font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
			font-weight: 400;
			min-width: 110px;
			white-space: nowrap;
		}

		.logs-table td.log-time {
			color: #000000;
		}

		html.dark .logs-table td.log-time {
			color: #ffffff;
		}

		.log-client {
			font-size: 0.75rem;
			line-height: 1.4;
			max-width: 220px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			color: #18181b;
		}

		html.dark .log-client {
			color: #e4e4e7;
		}

		.log-description {
			font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
			font-size: 0.6875rem;
			line-height: 1.4;
			max-width: 800px;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
			color: #71717a;
			padding: 4px 0;
		}

		html.dark .log-description {
			color: #a1a1aa;
		}

		.expand-btn {
			background: transparent;
			border: none;
			cursor: pointer;
			padding: 4px 8px;
			border-radius: 4px;
			color: #a1a1aa;
			font-size: 0.75rem;
			transition: background-color 0.2s ease, color 0.2s ease, transform 0.15s ease;
			display: inline-flex;
			align-items: center;
			justify-content: center;
		}

		.expand-btn i {
			transition: transform 0.1s ease;
		}

		.expand-btn.expanded i {
			transform: rotate(90deg);
		}

		.expand-btn:hover {
			color: var(--text-primary);
			transform: scale(1.1);
		}

		html.dark .expand-btn {
			color: #71717a;
		}

		html.dark .expand-btn:hover {
			color: #e4e4e7;
		}

		.log-item-expanded {
			background: var(--bg-secondary) !important;
			display: none;
		}

		.log-item-expanded.expanded {
			display: table-row;
		}

		html.dark .log-item-expanded {
			background: #18181b !important;
		}

		.log-item-expanded.expanded td {
			padding: 0 !important;
			border: none !important;
		}

		.log-item-expanded.expanded .log-description-expanded {
			padding: 12px 16px !important;
			font-size: 0.75rem !important;
		}

		.log-description-expanded {
			padding: 12px 16px !important;
			border-top: 1px solid var(--border-color);
		}

		.log-item-expanded .json-pretty {
			margin: 0;
			padding: 0;
			line-height: 1.6;
			font-size: 0.75rem;
		}

		.json-pretty {
			font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
			line-height: 1.6;
			color: var(--text-primary);
			margin: 0;
			padding: 0;
			white-space: pre-wrap;
			word-break: break-word;
			overflow-x: auto;
		}

		html.dark .json-pretty {
			color: #e4e4e7;
		}

		.status-indicator {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 22px;
			height: 22px;
			border-radius: 50%;
			flex-shrink: 0;
			font-size: 0.6rem;
			font-weight: 700;
			text-transform: uppercase;
			color: white;
			box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15);
		}

		.status-indicator.ok {
			background-color: #10b981;
		}

		html.dark .status-indicator.ok {
			background-color: #007a52;
		}

		.status-indicator.ko {
			background-color: #dc2626;
		}

		html.dark .status-indicator.ko {
			background-color: #c64545;
		}

		.pagination {
			padding: 20px 32px;
			border-top: none;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
			background: transparent;
		}

		html.dark .pagination {
			background: transparent;
		}

		.pagination-btn {
			padding: 8px 16px;
			border: 2px solid transparent;
			border-top: 2px solid transparent;
			border-radius: 0;
			background: transparent;
			color: #52525b;
			cursor: pointer;
			font-size: 0.875rem;
			line-height: 1.25rem;
			font-weight: 500;
			transition: color 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
			display: inline-flex;
			align-items: center;
		}

		.pagination-btn:hover:not(:disabled) {
			transform: translateY(-1px);
		}

		.pagination-btn:active:not(:disabled) {
			transform: translateY(0);
		}

		html.dark .pagination-btn {
			color: #a1a1aa;
		}

		.pagination-btn:hover:not(:disabled) {
			color: #18181b;
			border-top-color: #d4d4d8;
		}

		html.dark .pagination-btn:hover:not(:disabled) {
			color: #e4e4e7;
			border-top-color: #52525b;
		}

		.pagination-btn:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		.pagination-btn:focus {
			outline: none;
			border-radius: 6px;
			box-shadow: 0 0 0 2px #0ea5e9;
		}

		html.dark .pagination-btn:focus {
			box-shadow: 0 0 0 2px #0369a1;
		}

		.pagination-info {
			color: #52525b;
			font-size: 0.875rem;
			line-height: 1.25rem;
			font-weight: 500;
			padding: 8px 16px;
			border-top: 2px solid transparent;
		}

		html.dark .pagination-info {
			color: #a1a1aa;
		}

		.footer-info {
			position: absolute;
			bottom: 20px;
			right: 32px;
			display: flex;
			gap: 20px;
			font-size: 0.75rem;
			line-height: 1rem;
			color: #52525b;
			background: transparent;
		}

		html.dark .footer-info {
			color: #a1a1aa;
			background: transparent;
		}

		.loading {
			text-align: center;
			color: #52525b;
			font-size: 1rem;
			line-height: 1.5rem;
			font-weight: 500;
			display: flex;
			align-items: center;
			justify-content: center;
			height: 100%;
			min-height: 120px;
		}

		html.dark .loading {
			color: #a1a1aa;
		}

		.error-message {
			background: #fef2f2;
			color: #be123c;
			padding: 16px 20px;
			border-radius: 8px;
			margin: 20px 32px;
			border-left: 4px solid #ef4444;
		}

		html.dark .error-message {
			background: rgba(136, 19, 55, 0.4);
			color: #fb7185;
			border-color: #fb7185;
		}

		.empty-state {
			text-align: center;
			padding: 60px 20px;
			color: #52525b;
		}

		html.dark .empty-state {
			color: #a1a1aa;
		}

		.empty-state > div:last-child {
			font-weight: 600;
			margin-top: 10px;
		}

		.empty-state-icon {
			font-size: 3rem;
			line-height: 1;
			margin-bottom: 16px;
			opacity: 0.5;
		}

		/* Scrollbar styling */
		.sessions-scrollable::-webkit-scrollbar {
			width: 8px;
		}

		.sessions-scrollable::-webkit-scrollbar-track {
			background: var(--bg-secondary);
		}

		.sessions-scrollable::-webkit-scrollbar-thumb {
			background: var(--border-color);
			border-radius: 4px;
		}

		.sessions-scrollable::-webkit-scrollbar-thumb:hover {
			background: var(--text-secondary);
		}

		/* Table scrollbar - hidden by default, shown on hover (Mac-like behavior) */
		.logs-table-container > div:last-child::-webkit-scrollbar {
			width: 8px;
		}

		.logs-table-container > div:last-child::-webkit-scrollbar-track {
			background: transparent;
		}

		.logs-table-container > div:last-child::-webkit-scrollbar-thumb {
			background: transparent;
			border-radius: 4px;
		}

		.logs-table-container:hover > div:last-child::-webkit-scrollbar-thumb {
			background: var(--border-color);
		}

		.logs-table-container:hover > div:last-child::-webkit-scrollbar-thumb:hover {
			background: var(--text-secondary);
		}

		@media (max-width: 1200px) {
			.level-filters {
				width: 100%;
			}
			.search-controls {
				width: 100%;
			}
			.search-input {
				width: 100%;
			}
		}

		/* Actions dropdown styles */
		.actions-cell {
			position: relative;
			text-align: center;
			padding: 8px 4px;
		}

		.actions-btn {
			background: transparent;
			border: none;
			cursor: pointer;
			padding: 4px 8px;
			border-radius: 4px;
			color: #a1a1aa;
			font-size: 1.25rem;
			line-height: 1;
			transition: background-color 0.2s ease, color 0.2s ease;
			display: inline-flex;
			align-items: center;
			justify-content: center;
		}

		.actions-btn:hover {
			background: var(--hover-bg);
			color: var(--text-primary);
		}

		html.dark .actions-btn {
			color: #71717a;
		}

		html.dark .actions-btn:hover {
			color: #e4e4e7;
		}

		.actions-dropdown {
			position: fixed;
			background: white;
			border: 1px solid var(--border-color);
			border-radius: 6px;
			box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
			min-width: 150px;
			z-index: 1000;
			opacity: 0;
			transform: scale(0.95) translateY(-4px);
			pointer-events: none;
			overflow: hidden;
			display: block;
			visibility: visible;
			transition: opacity 0.15s ease-out, transform 0.15s ease-out;
		}

		html.dark .actions-dropdown {
			background: #27272a;
			border-color: #3f3f46;
			box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
		}

		.actions-dropdown.show {
			opacity: 1;
			transform: scale(1) translateY(0);
			pointer-events: auto;
			z-index: 10000;
			display: block;
			visibility: visible;
		}

		.actions-dropdown-item {
			padding: 8px 12px;
			cursor: pointer;
			transition: background-color 0.15s ease;
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 0.875rem;
			color: var(--text-primary);
		}

		.actions-dropdown-item:hover {
			background: var(--hover-bg);
		}

		.actions-dropdown-item.delete {
			color: #ef4444;
		}

		html.dark .actions-dropdown-item.delete {
			color: #fb7185;
		}

		.actions-dropdown-item.delete:hover {
			background: var(--level-error-bg);
		}
	</style>
</head>
	<body>
	<div class="main-container">
		<div class="content-wrapper">
			<div class="sidebar">
				<div class="sidebar-header">
					<div class="log-viewer-title text-xl font-semibold">Event log</div>
					<div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
						<a href="/" class="back-link text-sm text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-200">← Back to Home</a>
						<button onclick="handleLogout()" class="back-link text-sm text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-200" style="background: none; border: none; cursor: pointer; padding: 0;">Logout</button>
					</div>
				</div>
				<div class="sidebar-content">
					<div class="sidebar-title text-xs font-semibold uppercase tracking-wider">Sessions</div>
					<div class="all-sessions-container">
						<ul class="server-list list-none">
							<li class="server-item active" data-session="all">
								<div class="server-item-left">
									<span class="server-name text-sm">All Sessions</span>
								</div>
								<div class="server-item-right">
									<span class="server-size text-xs" id="totalSize">-</span>
								</div>
							</li>
						</ul>
					</div>
					<ul class="server-list list-none sessions-scrollable" id="sessionList">
					</ul>
				</div>
			</div>

			<div class="sidebar-resizer" id="sidebarResizer" aria-hidden="true"></div>

			<div class="main-content">
				<div class="main-content-header">
					<div class="level-filters">
						<button class="level-filter-btn level-info" data-level="session_start">
							<input type="checkbox" checked id="filter-session_start" class="w-4 h-4 cursor-pointer">
							<span class="text-sm font-medium">Session</span>
							<span class="level-count text-xs font-semibold" id="count-session_start">0</span>
						</button>
						<button class="level-filter-btn level-debug" data-level="tool_call">
							<input type="checkbox" checked id="filter-tool_call" class="w-4 h-4 cursor-pointer">
							<span class="text-sm font-medium">Tool</span>
							<span class="level-count text-xs font-semibold" id="count-tool_call">0</span>
						</button>
						<button class="level-filter-btn level-warning" data-level="custom">
							<input type="checkbox" checked id="filter-custom" class="w-4 h-4 cursor-pointer">
							<span class="text-sm font-medium">Custom</span>
							<span class="level-count text-xs font-semibold" id="count-custom">0</span>
						</button>
						<button class="level-filter-btn level-error" data-level="tool_error">
							<input type="checkbox" checked id="filter-tool_error" class="w-4 h-4 cursor-pointer">
							<span class="text-sm font-medium">Error</span>
							<span class="level-count text-xs font-semibold" id="count-tool_error">0</span>
						</button>
					</div>
					<div class="search-controls">
						<input type="text" class="search-input" id="searchInput" placeholder="Search">
						<div class="icon-buttons-group">
							<button type="button" class="icon-btn" onclick="refreshLogs(event)" title="Refresh"><i class="fa fa-refresh"></i></button>
							<button class="icon-btn delete-all-btn" onclick="confirmDeleteAll()" title="Delete all events"><i class="fa-regular fa-trash-can"></i></button>
							<button class="icon-btn notification-toggle" onclick="toggleNotificationMode()" title="Enable notifications"><i class="fa-regular fa-bell"></i></button>
							<button class="icon-btn theme-toggle" onclick="toggleTheme()" title="Toggle theme"><i class="fa-regular fa-moon"></i></button>
							<button class="icon-btn user-btn" id="userBtn" title="User" onclick="showUserMenu(event)"><i class="fa-regular fa-user"></i></button>
						</div>
					</div>
				</div>
				<div class="main-content-body">
					<div id="sessionActivityCard" class="session-activity-card hidden">
						<div class="session-activity-header">
							<div style="display: flex; align-items: center; gap: 8px;">
								<button class="date-nav-btn" id="prevDayBtn" onclick="navigateToPreviousDay()" title="Previous day">
									<i class="fa-solid fa-chevron-left"></i>
								</button>
								<div>
									<p id="sessionActivityTitle" class="label">Activity overview</p>
									<p id="sessionActivitySubtitle" class="subtitle">–</p>
								</div>
								<button class="date-nav-btn" id="nextDayBtn" onclick="navigateToNextDay()" title="Next day">
									<i class="fa-solid fa-chevron-right"></i>
								</button>
							</div>
							<div class="session-activity-legend-wrapper">
								<button
									type="button"
									class="session-activity-legend-toggle"
									title="Hover to see the sessions legend"
								>
									<img src="resources/colors.png" alt="" class="session-activity-legend-toggle-image">
									<span>Legend</span>
								</button>
							<div id="sessionActivityLegend" class="session-activity-legend">
								<span class="legend-item">
									<span class="legend-dot" style="background: #0ea5e9;"></span>
									<span>Events per slot</span>
								</span>
								<span class="legend-item">
									<span class="legend-dot" style="background: rgba(16,185,129,0.7);"></span>
									<span>Office window</span>
								</span>
								</div>
							</div>
						</div>
						<div id="sessionActivityChart"></div>
					</div>
					<div class="horizontal-resizer" id="horizontalResizer" aria-hidden="true"></div>
					<div class="table-controls" id="tableControls" style="display: none;">
						<div class="table-controls-right">
							<select class="control-select" id="sortSelect">
								<option value="DESC">Newest first</option>
								<option value="ASC">Oldest first</option>
							</select>
							<select class="control-select" id="limitSelect">
								<option value="25">25 items per page</option>
								<option value="50" selected>50 items per page</option>
								<option value="100">100 items per page</option>
							</select>
						</div>
					</div>
					<div class="logs-table-container" id="logsTableContainer">
						<div id="loadingMessage" class="loading">Loading events...</div>
						<div id="errorMessage" class="error-message" style="display: none;"></div>
						<div id="emptyState" class="empty-state" style="display: none;">
							<div class="font-semibold mt-2.5">No events found</div>
						</div>
						<div style="flex: 1; overflow-y: auto; min-height: 0;">
							<table class="logs-table" id="logsTable" style="display: none;">
								<thead>
									<tr>
										<th style="width: 40px;"></th>
										<th style="width: 40px;"></th>
										<th class="time-column" style="width: 110px;">Time</th>
										<th style="width: 130px;">Event</th>
										<th style="width: 200px;">Company</th>
										<th>Payload</th>
										<th style="width: 50px;"></th>
									</tr>
								</thead>
								<tbody id="logsBody">
								</tbody>
							</table>
						</div>
					</div>
					<div class="pagination" id="pagination" style="display: none;">
						<button class="pagination-btn" onclick="previousPage()" id="prevBtn">← Previous</button>
						<span class="pagination-info" id="pageInfo"></span>
						<button class="pagination-btn" onclick="nextPage()" id="nextBtn">Next →</button>
					</div>
					<div class="footer-info">
						<span class="text-xs">Load time: <span id="durationInfo" class="font-semibold">-</span></span>
						<span class="text-xs">Version: <span class="font-semibold">v1.0.0</span></span>
						<span class="text-xs" id="dbSizeInfo" style="display: none;">DB size: <span id="dbSize" class="font-semibold">-</span></span>
					</div>
				</div>
			</div>
		</div>
	</div>

	<script src="/vendor/echarts/echarts.min.js"></script>
	<script>
		const detectElectronEnvironment = () => {
			const userAgent = navigator?.userAgent?.toLowerCase() || '';
			if (userAgent.includes(' electron/')) {
				return true;
			}
			if (typeof window !== 'undefined' && window.process?.versions?.electron) {
				return true;
			}
			if (typeof navigator === 'object' && Array.isArray(navigator.plugins)) {
				return navigator.plugins.namedItem?.('Chromium PDF Plugin') && window.process?.type === 'renderer';
			}
			return false;
		};

		const isElectronRuntime = detectElectronEnvironment();
		window.__IS_ELECTRON__ = isElectronRuntime;
		document.documentElement.dataset.runtime = isElectronRuntime ? 'electron' : 'browser';
		document.body?.classList?.toggle('electron-runtime', isElectronRuntime);
		console.info(`[Telemetry Viewer] Runtime detected: ${isElectronRuntime ? 'Electron' : 'Browser'}`);
	</script>
	<script>
		// Check authentication status on page load
		(async () => {
			try {
				const response = await fetch('/api/auth/status');
				const data = await response.json();
				if (!data.authenticated) {
					window.location.href = '/login';
				}
			} catch (error) {
				console.error('Auth check failed:', error);
				window.location.href = '/login';
			}
		})();

		function showUserMenu(e) {
			e.stopPropagation();
			// For now, just show a simple alert with user info
			// In the future, this could show a dropdown menu
			fetch('/api/auth/status')
				.then(response => response.json())
				.then(data => {
					if (data.authenticated && data.username) {
						alert(`Logged in as: ${data.username}`);
					} else {
						handleLogout();
					}
				})
				.catch(() => {
					handleLogout();
				});
		}

		async function handleLogout() {
			try {
				const response = await fetch('/logout', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					}
				});
				if (response.ok) {
					window.location.href = '/login';
				}
			} catch (error) {
				console.error('Logout error:', error);
				window.location.href = '/login';
			}
		}

		// Helper function to handle authentication errors
		async function handleApiResponse(response) {
			if (response.status === 401) {
				window.location.href = '/login';
				return null;
			}
			if (!response.ok) {
				throw new Error(`HTTP error! status: ${response.status}`);
			}
			return response;
		}

		let currentOffset = 0;
		let limit = 50;
		let totalEvents = 0;
		let selectedSession = 'all';
		let selectedActivityDate = null; // null means use current day or event's day
		let activeFilters = new Set(['tool_call', 'session_start', 'custom', 'tool_error']);
		let searchQuery = '';
		let sortOrder = 'DESC';
		let startTime = performance.now();
		const NOTIFICATION_REFRESH_INTERVAL = 5 * 60 * 1000;
		let notificationModeEnabled = false;
		let notificationRefreshIntervalId = null;
		let lastKnownEventTimestamp = null;
		const knownSessionIds = new Set();
		const sessionDisplayMap = new Map();
		let sessionActivityChart = null;
		let lastSessionActivityEvents = [];
		const SESSION_ACTIVITY_FETCH_LIMIT = 1000;
		const SESSION_ACTIVITY_SLOT_MINUTES = 10;
		const SESSION_ACTIVITY_MARGIN_MINUTES = 30;
		const SESSION_SERIES_COLORS = [
			'#53cf98',
			'#38bdf8',
			'#f97316',
			'#a78bfa',
			'#fb7185',
			'#22d3ee',
			'#c084fc',
			'#f472b6'
		];
		const OFFICE_START = { hour: 8, minute: 30 };
		const OFFICE_END = { hour: 18, minute: 30 };
		let isResizingSidebar = false;
		let sidebarResizeStartX = 0;
		let sidebarResizeStartWidth = 0;
		let isResizingActivity = false;
		let activityResizeStartY = 0;
		let activityResizeStartHeight = 0;
		const globalErrorMessages = [];
		const MAX_GLOBAL_ERROR_MESSAGES = 3;

		// Theme management - using .dark class like Laravel Log Viewer
		// Detects system theme by default, but allows manual override
		function getSystemTheme() {
			return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
		}

		function applyTheme(theme) {
			if (theme === 'dark') {
				document.documentElement.classList.add('dark');
			} else {
				document.documentElement.classList.remove('dark');
			}
			updateThemeIcon(theme);
		}

		function initTheme() {
			const savedTheme = localStorage.getItem('theme');
			const theme = savedTheme || 'dark';
			applyTheme(theme);
		}

		function toggleTheme() {
			const isDark = document.documentElement.classList.contains('dark');
			const newTheme = isDark ? 'light' : 'dark';
			localStorage.setItem('theme', newTheme);
			applyTheme(newTheme);
			refreshSessionActivityTheme();
		}

		function updateThemeIcon(theme) {
			const iconBtn = document.querySelector('.theme-toggle');
			if (iconBtn) {
				if (theme === 'dark') {
					iconBtn.innerHTML = '<i class="fa-regular fa-sun"></i>';
				} else {
					iconBtn.innerHTML = '<i class="fa-regular fa-moon"></i>';
				}
			}
		}

		// Listen for system theme changes and update if no manual preference is set
		if (window.matchMedia) {
			const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
			mediaQuery.addEventListener('change', (e) => {
				// Only update if user hasn't manually set a preference
				if (!localStorage.getItem('theme')) {
					const newTheme = e.matches ? 'dark' : 'light';
					applyTheme(newTheme);
					refreshSessionActivityTheme();
				}
			});
		}

		// Level filter management
		function setupLevelFilters() {
			document.querySelectorAll('.level-filter-btn').forEach(btn => {
				const checkbox = btn.querySelector('input[type="checkbox"]');
				const level = btn.dataset.level;

				function updateButtonState() {
					if (checkbox.checked) {
						btn.classList.add('active');
						activeFilters.add(level);
					} else {
						btn.classList.remove('active');
						activeFilters.delete(level);
					}
				}

				checkbox.addEventListener('change', () => {
					updateButtonState();
					currentOffset = 0;
					loadEvents();
				});

				btn.addEventListener('click', (e) => {
					if (e.target !== checkbox) {
						checkbox.checked = !checkbox.checked;
						updateButtonState();
						checkbox.dispatchEvent(new Event('change'));
					}
				});

				// Initialize button state
				updateButtonState();
			});
		}

		function setupSidebarResizer() {
			const resizer = document.getElementById('sidebarResizer');
			const sidebar = document.querySelector('.sidebar');
			if (!resizer || !sidebar) {
				return;
			}

			const startResize = (event) => {
				const point = event.touches ? event.touches[0] : event;
				isResizingSidebar = true;
				sidebarResizeStartX = point.clientX;
				sidebarResizeStartWidth = sidebar.offsetWidth;
				document.body.classList.add('sidebar-resizing');
				document.addEventListener('mousemove', handleResize);
				document.addEventListener('mouseup', stopResize);
				document.addEventListener('touchmove', handleResize, { passive: false });
				document.addEventListener('touchend', stopResize);
				event.preventDefault();
			};

			const handleResize = (event) => {
				if (!isResizingSidebar) {
					return;
				}
				const point = event.touches ? event.touches[0] : event;
				const delta = point.clientX - sidebarResizeStartX;
				let newWidth = sidebarResizeStartWidth + delta;
				newWidth = Math.max(220, Math.min(500, newWidth));
				document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
			};

			const stopResize = () => {
				if (!isResizingSidebar) {
					return;
				}
				isResizingSidebar = false;
				document.body.classList.remove('sidebar-resizing');
				document.removeEventListener('mousemove', handleResize);
				document.removeEventListener('mouseup', stopResize);
				document.removeEventListener('touchmove', handleResize);
				document.removeEventListener('touchend', stopResize);
			};

			resizer.addEventListener('mousedown', startResize);
			resizer.addEventListener('touchstart', startResize, { passive: false });
		}

		function setupHorizontalResizer() {
			const resizer = document.getElementById('horizontalResizer');
			const activityCard = document.getElementById('sessionActivityCard');
			if (!resizer || !activityCard) {
				console.warn('Horizontal resizer: resizer or activityCard not found', { resizer, activityCard });
				return;
			}

			console.log('Horizontal resizer: setting up', { resizer, activityCard, isHidden: activityCard.classList.contains('hidden') });

			const updateResizerVisibility = () => {
				const isCardHidden = activityCard.classList.contains('hidden');
				// TEMPORALMENT: sempre visible per depurar
				// if (isCardHidden) {
				// 	resizer.classList.add('hidden');
				// } else {
				// 	resizer.classList.remove('hidden');
				// }
				resizer.classList.remove('hidden'); // TEMPORAL: sempre visible
				console.log('Horizontal resizer: visibility updated', { isCardHidden, resizerHidden: resizer.classList.contains('hidden'), resizerStyles: window.getComputedStyle(resizer) });
			};

			// Update visibility when card visibility changes
			const observer = new MutationObserver(updateResizerVisibility);
			observer.observe(activityCard, { attributes: true, attributeFilter: ['class'] });
			updateResizerVisibility();

			const startResize = (event) => {
				const point = event.touches ? event.touches[0] : event;
				isResizingActivity = true;
				activityResizeStartY = point.clientY;
				activityResizeStartHeight = activityCard.offsetHeight;
				document.body.classList.add('activity-resizing');
				document.addEventListener('mousemove', handleResize);
				document.addEventListener('mouseup', stopResize);
				document.addEventListener('touchmove', handleResize, { passive: false });
				document.addEventListener('touchend', stopResize);
				event.preventDefault();
			};

			const handleResize = (event) => {
				if (!isResizingActivity) {
					return;
				}
				const point = event.touches ? event.touches[0] : event;
				const delta = point.clientY - activityResizeStartY;
				let newHeight = activityResizeStartHeight + delta;
				newHeight = Math.max(190, Math.min(600, newHeight));
				activityCard.style.height = `${newHeight}px`;
				// Redimensionar la gràfica per adaptar-se al nou espai
				if (sessionActivityChart) {
					sessionActivityChart.resize();
				}
			};

			const stopResize = () => {
				if (!isResizingActivity) {
					return;
				}
				isResizingActivity = false;
				document.body.classList.remove('activity-resizing');
				document.removeEventListener('mousemove', handleResize);
				document.removeEventListener('mouseup', stopResize);
				document.removeEventListener('touchmove', handleResize);
				document.removeEventListener('touchend', stopResize);
				// Assegurar que la gràfica es redimensiona quan s'acaba el redimensionament
				if (sessionActivityChart) {
					setTimeout(() => {
						sessionActivityChart.resize();
					}, 0);
				}
			};

			resizer.addEventListener('mousedown', startResize);
			resizer.addEventListener('touchstart', startResize, { passive: false });
		}

		function initSessionActivityChart() {
			if (sessionActivityChart) {
				return sessionActivityChart;
			}
			const chartEl = document.getElementById('sessionActivityChart');
			if (!chartEl || typeof echarts === 'undefined') {
				return null;
			}
			sessionActivityChart = echarts.init(chartEl);
			window.addEventListener('resize', () => {
				sessionActivityChart?.resize();
			});
			return sessionActivityChart;
		}

		function hideSessionActivityCard() {
			const card = document.getElementById('sessionActivityCard');
			if (card) {
				card.classList.add('hidden');
			}
			const title = document.getElementById('sessionActivityTitle');
			if (title) {
				title.textContent = 'Activity overview';
			}
			const subtitle = document.getElementById('sessionActivitySubtitle');
			if (subtitle) {
				subtitle.textContent = '–';
			}
			lastSessionActivityEvents = [];
			if (sessionActivityChart) {
				sessionActivityChart.clear();
			}
		}

		function showSessionActivityCard() {
			const card = document.getElementById('sessionActivityCard');
			if (card) {
				card.classList.remove('hidden');
			}
		}

		async function fetchAllSessionsActivityEvents() {
			const params = new URLSearchParams({
				limit: SESSION_ACTIVITY_FETCH_LIMIT.toString(),
				orderBy: 'created_at',
				order: 'ASC'
			});

			const response = await fetch(`/api/events?${params}`);
			const validResponse = await handleApiResponse(response);
			if (!validResponse) return [];
			const data = await validResponse.json();
			return Array.isArray(data.events) ? data.events : [];
		}

		async function updateSessionActivityChart(options = {}) {
			const eventsOverride = Array.isArray(options.events) ? options.events : null;
			const targetSession = typeof options.sessionId !== 'undefined' ? options.sessionId : selectedSession;

			if (eventsOverride && eventsOverride.length > 0) {
				renderSessionActivityChart(eventsOverride, { sessionId: targetSession });
				return;
			}

			if (targetSession === 'all') {
				try {
					const allEvents = await fetchAllSessionsActivityEvents();
					if (allEvents.length === 0) {
						hideSessionActivityCard();
						return;
					}
					renderSessionActivityChart(allEvents, { sessionId: 'all' });
				} catch (error) {
					handleInitializationError('all sessions activity chart', error);
					hideSessionActivityCard();
				}
				return;
			}

			try {
				const params = new URLSearchParams({
					sessionId: targetSession,
					orderBy: 'created_at',
					order: 'ASC',
					limit: SESSION_ACTIVITY_FETCH_LIMIT.toString()
				});
				const response = await fetch(`/api/events?${params}`);
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;
				const data = await validResponse.json();
				if (!data.events || data.events.length === 0) {
					hideSessionActivityCard();
					return;
				}
				renderSessionActivityChart(data.events, { sessionId: targetSession });
			} catch (error) {
				console.error('Error loading session activity chart:', error);
				hideSessionActivityCard();
			}
		}

		function renderSessionActivityChart(events, options = {}) {
			if (!Array.isArray(events) || events.length === 0) {
				hideSessionActivityCard();
				return;
			}

			const chartInstance = initSessionActivityChart();
			if (!chartInstance) {
				return;
			}

			lastSessionActivityEvents = events.slice();
			const targetSession = options.sessionId || selectedSession;
			const uniqueSessions = Array.from(new Set(events.map(evt => evt.session_id || 'Unknown session')));
			const isAllSessionsView = targetSession === 'all' && uniqueSessions.length > 0;

			let seriesData = [];
			let windowStart;
			let windowEnd;
			let referenceDate;
			let officeStart;
			let officeEnd;
			let maxBucketCount;
			let multiSeriesEntries = [];

			if (isAllSessionsView) {
				// For "All sessions", use selected date or current day
				const useCurrentDay = selectedActivityDate === null;
				const dateToUse = selectedActivityDate || new Date();
				const multiSeries = buildMultiSessionActivitySeries(events, useCurrentDay, dateToUse);
				windowStart = multiSeries.windowStart;
				windowEnd = multiSeries.windowEnd;
				referenceDate = multiSeries.referenceDate;
				officeStart = multiSeries.officeStart;
				officeEnd = multiSeries.officeEnd;
				maxBucketCount = multiSeries.maxBucketCount;
				multiSeriesEntries = multiSeries.seriesList;
			} else {
				// For specific session, use selected date or the session's day
				const useCurrentDay = selectedActivityDate !== null;
				const dateToUse = selectedActivityDate || null;
				const singleSeries = buildSessionActivitySeries(events, useCurrentDay, dateToUse);
				({
					seriesData,
					windowStart,
					windowEnd,
					referenceDate,
					officeStart,
					officeEnd,
					maxBucketCount
				} = singleSeries);
			}

			const totalEvents = events.length;
			const sessionCount = uniqueSessions.length;
			const formattedDate = formatHumanDate(referenceDate);

			// Update the title with the date
			const title = document.getElementById('sessionActivityTitle');
			if (title) {
				title.textContent = `Activity for ${formattedDate}`;
			}

			// Update navigation buttons state
			updateDateNavigationButtons(referenceDate);

			const subtitle = document.getElementById('sessionActivitySubtitle');
			if (subtitle) {
				const eventLabel = totalEvents === 1 ? 'event' : 'events';
				if (isAllSessionsView) {
					const sessionLabel = sessionCount === 1 ? 'session' : 'sessions';
					subtitle.textContent = `${formattedDate} · ${sessionCount} ${sessionLabel} · ${totalEvents} ${eventLabel}`;
				} else {
					subtitle.textContent = `${formattedDate} · ${totalEvents} ${eventLabel}`;
				}
			}
			showSessionActivityCard();

			const themeIsDark = document.documentElement.classList.contains('dark');
			const axisColor = themeIsDark ? '#a1a1aa' : '#52525b';
			const splitLineColor = themeIsDark ? 'rgba(63, 63, 70, 0.35)' : 'rgba(228, 228, 231, 0.35)';
			const gradientCap = 70;
			const yAxisMax = Math.max(20, maxBucketCount || 0);
			const warmOffset = Math.min(gradientCap / Math.max(yAxisMax, 1), 1);

			let chartSeries = [];
			if (isAllSessionsView) {
				chartSeries = multiSeriesEntries.map((entry, index) => {
					const color = SESSION_SERIES_COLORS[index % SESSION_SERIES_COLORS.length];
					return createMultiSessionSeriesOption(entry.sessionId, entry.seriesData, color);
				});
			} else {
				chartSeries = [createSingleSessionSeriesOption(seriesData, warmOffset)];
			}

			chartInstance.setOption({
				grid: { left: 45, right: 20, top: 15, bottom: 30 },
				xAxis: {
					type: 'time',
					min: windowStart.getTime(),
					max: windowEnd.getTime(),
					axisLabel: {
						color: axisColor,
						formatter: value => formatChartTimeLabel(new Date(value))
					},
					axisLine: { lineStyle: { color: axisColor } },
					splitLine: { show: true, lineStyle: { color: splitLineColor } },
					axisTick: { show: false }
				},
				yAxis: {
					type: 'value',
					min: 0,
					max: yAxisMax,
					minInterval: 1,
					name: 'Events',
					nameGap: 22,
					nameTextStyle: { color: axisColor },
					axisLabel: { color: axisColor },
					axisLine: { show: false },
					splitLine: { lineStyle: { color: splitLineColor } }
				},
				tooltip: {
					trigger: 'axis',
					axisPointer: { type: 'line' },
					formatter: function(params) {
						if (!Array.isArray(params)) {
							params = [params];
						}
						// Filtrar les sèries amb valor 0 o null
						const filteredParams = params.filter(param => {
							// Extract the actual numeric value from param.value
							// For time-series data, value can be [timestamp, value] or just the value
							let value = param.value;
							if (Array.isArray(value) && value.length >= 2) {
								// If it's an array, the second element is the actual value
								value = value[1];
							}
							return value !== null && value !== undefined && value !== 0;
						});
						// Si no hi ha cap sèrie vàlida, no mostrar el tooltip
						if (filteredParams.length === 0) {
							return '';
						}
						// Construir el contingut del tooltip amb les sèries filtrades
						let result = '';
						if (filteredParams.length > 0 && filteredParams[0].axisValue) {
							const date = new Date(filteredParams[0].axisValue);
							result += `<div style="margin-bottom: 4px; font-weight: 500;">${formatHumanDate(date)} ${formatChartTimeLabel(date)}</div>`;
						}
						filteredParams.forEach(param => {
							// Extract the actual numeric value
							let value = param.value;
							if (Array.isArray(value) && value.length >= 2) {
								// If it's an array, the second element is the actual value
								value = value[1];
							}
							const eventLabel = value === 1 ? 'event' : 'events';
							const marker = `<span style="display:inline-block;margin-right:4px;border-radius:50%;width:10px;height:10px;background-color:${param.color};"></span>`;
							result += `<div style="margin: 2px 0;">${marker}${param.seriesName}: <strong>${value} ${eventLabel}</strong></div>`;
						});
						return result;
					}
				},
				series: chartSeries,
				markArea: {
					itemStyle: { color: 'rgba(16,185,129,0.12)' },
					data: [
						[
							{ xAxis: officeStart.getTime() },
							{ xAxis: officeEnd.getTime() }
						]
					]
				}
			}, true);

			chartInstance.resize();
			renderSessionActivityLegend(isAllSessionsView ? chartSeries.map(series => ({
				name: series.name,
				color: series.lineStyle?.color || '#53cf98'
			})) : null);
		}

		function buildSessionActivitySeries(events, useCurrentDay = false, customDate = null) {
			// Use custom date if provided, otherwise use current day if useCurrentDay is true, otherwise use the session's day
			let referenceDate;
			if (customDate) {
				referenceDate = new Date(customDate);
			} else if (useCurrentDay) {
				referenceDate = new Date();
			} else {
				referenceDate = new Date(events[0].timestamp);
			}
			const eventTimes = events
				.map(event => Date.parse(event.timestamp))
				.filter(time => !Number.isNaN(time));
			const minEventTime = eventTimes.length ? Math.min(...eventTimes) : null;
			const maxEventTime = eventTimes.length ? Math.max(...eventTimes) : null;
			const { start: windowStart, end: windowEnd } = getExtendedWindow(referenceDate, minEventTime, maxEventTime);
			const officeStart = new Date(referenceDate);
			officeStart.setHours(OFFICE_START.hour, OFFICE_START.minute, 0, 0);
			const officeEnd = new Date(referenceDate);
			officeEnd.setHours(OFFICE_END.hour, OFFICE_END.minute, 0, 0);
			const slotMs = SESSION_ACTIVITY_SLOT_MINUTES * 60 * 1000;
			const slotCount = Math.floor((windowEnd.getTime() - windowStart.getTime()) / slotMs) + 1;
			const buckets = Array.from({ length: slotCount }, () => 0);

			events.forEach(event => {
				const time = Date.parse(event.timestamp);
				if (Number.isNaN(time)) {
					return;
				}
				const bucketIndex = Math.floor((time - windowStart.getTime()) / slotMs);
				if (bucketIndex >= 0 && bucketIndex < buckets.length) {
					buckets[bucketIndex] += 1;
				}
			});

			const seriesData = buckets.map((count, index) => {
				const ts = windowStart.getTime() + (index * slotMs);
				// Use 0 for zero values so the line is always visible
				return [ts, count];
			});

			const maxBucketCount = buckets.length ? Math.max(...buckets) : 0;

			return { seriesData, windowStart, windowEnd, referenceDate, officeStart, officeEnd, maxBucketCount };
		}

		function buildMultiSessionActivitySeries(events, useCurrentDay = false, customDate = null) {
			// Use custom date if provided, otherwise use current day if useCurrentDay is true, otherwise use the first event's day
			let referenceDate;
			if (customDate) {
				referenceDate = new Date(customDate);
			} else if (useCurrentDay) {
				referenceDate = new Date();
			} else {
				referenceDate = new Date(events[0].timestamp);
			}
			const eventTimes = events
				.map(event => Date.parse(event.timestamp))
				.filter(time => !Number.isNaN(time));
			const minEventTime = eventTimes.length ? Math.min(...eventTimes) : null;
			const maxEventTime = eventTimes.length ? Math.max(...eventTimes) : null;
			const { start: windowStart, end: windowEnd } = getExtendedWindow(referenceDate, minEventTime, maxEventTime);
			const officeStart = new Date(referenceDate);
			officeStart.setHours(OFFICE_START.hour, OFFICE_START.minute, 0, 0);
			const officeEnd = new Date(referenceDate);
			officeEnd.setHours(OFFICE_END.hour, OFFICE_END.minute, 0, 0);
			const slotMs = SESSION_ACTIVITY_SLOT_MINUTES * 60 * 1000;
			const slotCount = Math.floor((windowEnd.getTime() - windowStart.getTime()) / slotMs) + 1;

			const sessionBuckets = new Map();

			events.forEach(event => {
				const time = Date.parse(event.timestamp);
				if (Number.isNaN(time)) {
					return;
				}
				const sessionId = event.session_id || 'Unknown session';
				if (!sessionBuckets.has(sessionId)) {
					sessionBuckets.set(sessionId, Array.from({ length: slotCount }, () => 0));
				}
				const bucketIndex = Math.floor((time - windowStart.getTime()) / slotMs);
				if (bucketIndex >= 0 && bucketIndex < slotCount) {
					const buckets = sessionBuckets.get(sessionId);
					buckets[bucketIndex] += 1;
				}
			});

			const seriesList = [];
			let maxBucketCount = 0;

			sessionBuckets.forEach((buckets, sessionId) => {
				const seriesData = buckets.map((count, index) => {
					const ts = windowStart.getTime() + (index * slotMs);
					// Use 0 for zero values so the line is always visible
					return [ts, count];
				});
				maxBucketCount = Math.max(maxBucketCount, ...buckets, maxBucketCount);
				seriesList.push({
					sessionId,
					seriesData
				});
			});

			return { seriesList, windowStart, windowEnd, referenceDate, officeStart, officeEnd, maxBucketCount };
		}

		function getExtendedWindow(referenceDate, minEventTime, maxEventTime) {
			// Start with office hours as base (9-18h)
			const officeStart = new Date(referenceDate);
			officeStart.setHours(OFFICE_START.hour, OFFICE_START.minute, 0, 0);
			const officeEnd = new Date(referenceDate);
			officeEnd.setHours(OFFICE_END.hour, OFFICE_END.minute, 0, 0);

			// If we have event times, expand the window to include all events
			// but keep it within the same day as referenceDate
			let start = officeStart;
			let end = officeEnd;

			if (minEventTime !== null && maxEventTime !== null) {
				const minEventDate = new Date(minEventTime);
				const maxEventDate = new Date(maxEventTime);

				// Get the day boundaries for referenceDate
				const refDay = referenceDate.getDate();
				const refMonth = referenceDate.getMonth();
				const refYear = referenceDate.getFullYear();

				// Check if events are on the same day as referenceDate
				const minEventDay = minEventDate.getDate();
				const minEventMonth = minEventDate.getMonth();
				const minEventYear = minEventDate.getFullYear();
				const maxEventDay = maxEventDate.getDate();
				const maxEventMonth = maxEventDate.getMonth();
				const maxEventYear = maxEventDate.getFullYear();

				const isSameDay = (minEventDay === refDay && minEventMonth === refMonth && minEventYear === refYear) ||
				                  (maxEventDay === refDay && maxEventMonth === refMonth && maxEventYear === refYear);

				if (isSameDay) {
					// Adjust start to include earliest event
					const earliestEvent = new Date(minEventDate);
					earliestEvent.setFullYear(refYear, refMonth, refDay);
					if (earliestEvent < start) {
						start = earliestEvent;
						// Round down to the previous slot boundary
						const slotMs = SESSION_ACTIVITY_SLOT_MINUTES * 60 * 1000;
						const remainder = start.getTime() % slotMs;
						if (remainder > 0) {
							start = new Date(start.getTime() - remainder);
						}
					}

					// Adjust end to include latest event
					const latestEvent = new Date(maxEventDate);
					latestEvent.setFullYear(refYear, refMonth, refDay);
					if (latestEvent > end) {
						end = latestEvent;
						// Round up to the next slot boundary
						const slotMs = SESSION_ACTIVITY_SLOT_MINUTES * 60 * 1000;
						const remainder = end.getTime() % slotMs;
						if (remainder > 0) {
							end = new Date(end.getTime() + slotMs - remainder);
						}
					}
				}
			}

			return { start, end };
		}

		function formatChartTimeLabel(dateObj) {
			if (!(dateObj instanceof Date)) {
				return '';
			}
			return `${padNumber(dateObj.getHours())}:${padNumber(dateObj.getMinutes())}`;
		}

		function navigateToPreviousDay() {
			if (!lastSessionActivityEvents || lastSessionActivityEvents.length === 0) {
				return;
			}

			// Get current reference date
			const currentDate = selectedActivityDate || new Date();
			const previousDate = new Date(currentDate);
			previousDate.setDate(previousDate.getDate() - 1);

			selectedActivityDate = previousDate;
			renderSessionActivityChart(lastSessionActivityEvents, { sessionId: selectedSession });
		}

		function navigateToNextDay() {
			if (!lastSessionActivityEvents || lastSessionActivityEvents.length === 0) {
				return;
			}

			// Get current reference date
			const currentDate = selectedActivityDate || new Date();
			const nextDate = new Date(currentDate);
			nextDate.setDate(nextDate.getDate() + 1);

			// Don't allow navigating to future dates
			const today = new Date();
			today.setHours(23, 59, 59, 999);
			if (nextDate > today) {
				return;
			}

			selectedActivityDate = nextDate;
			renderSessionActivityChart(lastSessionActivityEvents, { sessionId: selectedSession });
		}

		function updateDateNavigationButtons(referenceDate) {
			const prevBtn = document.getElementById('prevDayBtn');
			const nextBtn = document.getElementById('nextDayBtn');

			if (!prevBtn || !nextBtn) return;

			// Disable next button if we're at today
			const today = new Date();
			today.setHours(23, 59, 59, 999);
			const refDate = new Date(referenceDate);
			refDate.setHours(23, 59, 59, 999);

			nextBtn.disabled = refDate >= today;

			// Previous button is always enabled (we can go back as far as we want)
			prevBtn.disabled = false;
		}

		function formatHumanDate(dateObj) {
			if (!(dateObj instanceof Date)) {
				return '';
			}
			const day = padNumber(dateObj.getDate());
			const month = padNumber(dateObj.getMonth() + 1);
			const year = dateObj.getFullYear();
			return `${day}/${month}/${year}`;
		}

		function padNumber(value) {
			return String(value).padStart(2, '0');
		}

		function showGlobalError(message) {
			const banner = document.getElementById('globalErrorBanner');
			if (!banner || !message) {
				return;
			}
			const formattedMessage = typeof message === 'string'
				? message
				: (message?.message || 'Unexpected error');
			globalErrorMessages.unshift(formattedMessage);
			if (globalErrorMessages.length > MAX_GLOBAL_ERROR_MESSAGES) {
				globalErrorMessages.length = MAX_GLOBAL_ERROR_MESSAGES;
			}
			banner.innerHTML = globalErrorMessages
				.map(msg => `<div>${escapeHtml(msg)}</div>`)
				.join('');
			banner.classList.remove('hidden');
		}

		function handleInitializationError(context, error) {
			const details = error?.message || error || 'Unknown error';
			console.error(`Initialization error (${context}):`, error);
			showGlobalError(`Initialization error (${context}): ${details}`);
		}

		function runSafeInitStep(label, fn) {
			try {
				if (typeof fn === 'function') {
					fn();
				}
			} catch (error) {
				handleInitializationError(label, error);
			}
		}

		function runSafeAsyncInitStep(label, fn) {
			try {
				const result = typeof fn === 'function' ? fn() : null;
				if (result && typeof result.catch === 'function') {
					result.catch(error => handleInitializationError(label, error));
				}
			} catch (error) {
				handleInitializationError(label, error);
			}
		}

		function createSingleSessionSeriesOption(seriesData, warmOffset) {
			return {
				name: 'Events',
				type: 'line',
				smooth: 0.25,
				smoothMonotone: 'x', // prevent bezier overshoot while keeping curvature
				showSymbol: false,
				connectNulls: true, // Connect valid points even if there are null values between them
				lineStyle: { width: 3, color: hexToRgba('#53cf98', 0.5) }, // More transparent line
				areaStyle: {
					color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
						{ offset: 0, color: 'rgba(133,230,185,0.45)' },
						{ offset: warmOffset, color: 'rgba(197,241,221,0.35)' },
						{ offset: 1, color: 'rgba(216,247,232,0.16)' }
					])
				},
				data: seriesData
			};
		}

		function createMultiSessionSeriesOption(sessionId, seriesData, color) {
			const startColor = hexToRgba(color, 0.35);
			const endColor = hexToRgba(color, 0.05);
			return {
				name: formatSessionLabel(sessionId),
				type: 'line',
				smooth: 0.65,
				smoothMonotone: 'x',
				showSymbol: false,
				connectNulls: true, // Connect valid points even if there are null values between them
				lineStyle: { width: 2.5, color: hexToRgba(color, 0.5) }, // More transparent line
				areaStyle: {
					color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
						{ offset: 0, color: startColor },
						{ offset: 1, color: endColor }
					])
				},
				data: seriesData
			};
		}

		function hexToRgba(hex, alpha = 1) {
			if (typeof hex !== 'string') {
				return `rgba(83, 207, 152, ${alpha})`;
			}
			let sanitized = hex.replace('#', '');
			if (sanitized.length === 3) {
				sanitized = sanitized.split('').map(ch => ch + ch).join('');
			}
			const bigint = parseInt(sanitized, 16);
			if (Number.isNaN(bigint)) {
				return `rgba(83, 207, 152, ${alpha})`;
			}
			const r = (bigint >> 16) & 255;
			const g = (bigint >> 8) & 255;
			const b = bigint & 255;
			return `rgba(${r}, ${g}, ${b}, ${alpha})`;
		}

		function formatSessionLabel(sessionId) {
			if (!sessionId) {
				return 'Unknown session';
			}
			const storedLabel = sessionDisplayMap.get(sessionId);
			if (storedLabel) {
				return storedLabel;
			}
			if (sessionId.length <= 22) {
				return sessionId;
			}
			return `${sessionId.slice(0, 10)}…${sessionId.slice(-6)}`;
		}

		function formatSessionDisplay(session) {
			const fallbackId = session?.session_id || 'Unknown session';
			const fallbackShort = fallbackId.length > 12 ? `${fallbackId.substring(0, 12)}...` : fallbackId;
			const fallbackHtml = `<span class="session-date">${escapeHtml(fallbackShort)}</span>`;

			if (!session || !session.first_event) {
				return { html: fallbackHtml, text: fallbackShort };
			}

			const parsedDate = new Date(session.first_event);
			if (Number.isNaN(parsedDate.getTime())) {
				return { html: fallbackHtml, text: fallbackShort };
			}

			const day = parsedDate.getDate();
			const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
			const month = monthNames[parsedDate.getMonth()];
			const hours = parsedDate.getHours();
			const minutes = String(parsedDate.getMinutes()).padStart(2, '0');
			const dateStr = `${day} ${month} ${hours}:${minutes}`;
			const dateHtml = `<span class="session-date">${escapeHtml(dateStr)}</span>`;

			let userText = '';
			if (session.user_name) {
				userText = session.user_name;
			} else if (session.user_id) {
				userText = session.user_id;
			}

			if (!userText) {
				return { html: dateHtml, text: dateStr };
			}

			const userHtml = `<span class="session-user"> • ${escapeHtml(userText)}</span>`;
			return { html: `${dateHtml}${userHtml}`, text: `${dateStr} • ${userText}` };
		}

		function escapeHtml(str) {
			return String(str ?? '')
				.replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/"/g, '&quot;')
				.replace(/'/g, '&#39;');
		}

		function renderSessionActivityLegend(seriesEntries) {
			const legendEl = document.getElementById('sessionActivityLegend');
			if (!legendEl) {
				return;
			}

			legendEl.innerHTML = '';

			// Only show legend when there are multiple series (multiple sessions)
			if (Array.isArray(seriesEntries) && seriesEntries.length > 0) {
				seriesEntries.forEach(entry => {
					const safeName = escapeHtml(entry.name);
					const item = document.createElement('span');
					item.className = 'legend-item';
					item.innerHTML = `
						<span class="legend-dot" style="background: ${entry.color};"></span>
						<span>${safeName}</span>
					`;
					legendEl.appendChild(item);
				});
			}
			// No legend for single session view - the chart is self-explanatory
		}

		function refreshSessionActivityTheme() {
			if (lastSessionActivityEvents.length > 0) {
				renderSessionActivityChart(lastSessionActivityEvents);
			} else if (sessionActivityChart) {
				sessionActivityChart.resize();
			}
		}

		async function loadEventTypeStats(sessionId = null) {
			try {
				const params = sessionId && sessionId !== 'all'
					? `?sessionId=${encodeURIComponent(sessionId)}`
					: '';
				const response = await fetch(`/api/event-types${params}`);
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;
				const stats = await validResponse.json();

				stats.forEach(stat => {
					const countEl = document.getElementById(`count-${stat.event}`);
					if (countEl) {
						countEl.textContent = stat.count || 0;
					}
				});

				// Update total size
				const total = stats.reduce((sum, stat) => sum + (stat.count || 0), 0);
				const totalSizeEl = document.getElementById('totalSize');
				if (totalSizeEl) {
					totalSizeEl.textContent = total;
				}
			} catch (error) {
				console.error('Error loading event type stats:', error);
			}
		}

		async function loadSessions() {
			try {
				const response = await fetch('/api/sessions');
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;
				const sessions = await validResponse.json();
				const sessionList = document.getElementById('sessionList');

				if (!sessionList) {
					console.error('sessionList element not found');
					return;
				}

				// Clear the scrollable list (All Sessions is now separate)
				sessionList.innerHTML = '';

				// Reset keyboard navigation for sessions when sessions are reloaded
				if (keyboardNavigationMode === 'sessions') {
					selectedSessionIndex = -1;
				}

				// Add each session
				if (Array.isArray(sessions) && sessions.length > 0) {
					const discoveredSessionIds = [];
					sessions.forEach(session => {
						if (!session || !session.session_id) {
							console.warn('Invalid session data:', session);
							return;
						}
						discoveredSessionIds.push(session.session_id);

						const li = document.createElement('li');
						li.className = 'server-item';
						li.setAttribute('data-session', session.session_id);

						// Format session display: date and user
						const { html: sessionDisplayHtml, text: sessionLabelText } = formatSessionDisplay(session);
						sessionDisplayMap.set(session.session_id, sessionLabelText);

						const activeIndicator = session.is_active ? '<span class="session-active-indicator"></span>' : '';
						li.innerHTML = `
							<div class="server-item-left">
								${activeIndicator}
								<span class="server-name text-sm">${sessionDisplayHtml}</span>
							</div>
							<div class="server-item-right">
								<span class="server-size text-xs">${session.count || 0}</span>
								<div class="server-item-actions">
									<button class="actions-btn" onclick="event.stopPropagation(); toggleSessionActionsDropdown(event, '${session.session_id}')" title="Actions">
										<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
											<circle cx="8" cy="3" r="1.5"/>
											<circle cx="8" cy="8" r="1.5"/>
											<circle cx="8" cy="13" r="1.5"/>
										</svg>
									</button>
									<div class="actions-dropdown" id="session-dropdown-${session.session_id}">
										<div class="actions-dropdown-item delete" onclick="event.stopPropagation(); confirmDeleteSession('${session.session_id}')">
											<span>🗑️</span>
											<span>Delete</span>
										</div>
									</div>
								</div>
							</div>
						`;

						li.addEventListener('click', (e) => {
							// Don't activate session if clicking on actions button
							if (e.target.closest('.server-item-actions')) {
								return;
							}
							document.querySelectorAll('.server-item').forEach(i => i.classList.remove('active'));
							li.classList.add('active');
							selectedSession = session.session_id;
							selectedActivityDate = null; // Reset to default when changing session
							// When a session is selected, default to ASC order (oldest first)
							if (selectedSession !== 'all') {
								sortOrder = 'ASC';
								document.getElementById('sortSelect').value = 'ASC';
							} else {
								sortOrder = 'DESC';
								document.getElementById('sortSelect').value = 'DESC';
							}
							currentOffset = 0;
							loadEvents();
							loadEventTypeStats(selectedSession);
						});

						sessionList.appendChild(li);
					});

					rememberSessionsFromList(discoveredSessionIds);

					// Update total size
					const total = sessions.reduce((sum, session) => sum + (session.count || 0), 0);
					const totalSizeEl = document.getElementById('totalSize');
					if (totalSizeEl) {
						totalSizeEl.textContent = total;
					}
				} else {
					// Update total size to 0 if no sessions
					const totalSizeEl = document.getElementById('totalSize');
					if (totalSizeEl) {
						totalSizeEl.textContent = '0';
					}
				}
			} catch (error) {
				console.error('Error loading sessions:', error);
				// Show error in console but don't break the UI
			}
		}

		async function loadEvents(options = {}) {
			const triggeredByNotification = Boolean(options.triggeredByNotification);
			const skipUiReset = Boolean(options.skipUiReset);
			startTime = performance.now();
			const loadingMessageEl = document.getElementById('loadingMessage');
			const logsTableEl = document.getElementById('logsTable');
			const paginationEl = document.getElementById('pagination');
			const tableControlsEl = document.getElementById('tableControls');
			const errorMessageEl = document.getElementById('errorMessage');
			const emptyStateEl = document.getElementById('emptyState');

			if (triggeredByNotification || skipUiReset) {
				if (loadingMessageEl) {
					loadingMessageEl.style.display = 'none';
				}
			} else {
				if (loadingMessageEl) {
					loadingMessageEl.style.display = 'block';
				}
				if (logsTableEl) {
					logsTableEl.style.display = 'none';
				}
				if (paginationEl) {
					paginationEl.style.display = 'none';
				}
				if (tableControlsEl) {
					tableControlsEl.style.display = 'none';
				}
			}

			if (errorMessageEl) {
				errorMessageEl.style.display = 'none';
			}
			if (emptyStateEl) {
				emptyStateEl.style.display = 'none';
			}

			try {
				const params = new URLSearchParams({
					limit: limit.toString(),
					offset: currentOffset.toString(),
					orderBy: 'created_at',
					order: sortOrder
				});

				// Apply level filters
				if (activeFilters.size > 0 && activeFilters.size < 4) {
					Array.from(activeFilters).forEach(level => {
						params.append('eventType', level);
					});
				}

				if (selectedSession !== 'all') {
					params.append('sessionId', selectedSession);
				}

				if (searchQuery) {
					params.append('search', searchQuery);
				}

				const response = await fetch(`/api/events?${params}`);
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;
				const data = await validResponse.json();

				const duration = Math.round(performance.now() - startTime);
				document.getElementById('durationInfo').textContent = `${duration}ms`;

				if (data.events && data.events.length > 0) {
					displayEvents(data.events);
					updatePagination(data);
					document.getElementById('logsTable').style.display = 'table';
					document.getElementById('pagination').style.display = 'flex';
					document.getElementById('tableControls').style.display = 'flex';
					handleNotificationState(data.events, triggeredByNotification);
					updateSessionActivityChart({ sessionId: selectedSession });
				} else {
					document.getElementById('emptyState').style.display = 'block';
					document.getElementById('tableControls').style.display = 'none';
					hideSessionActivityCard();
				}
			} catch (error) {
				console.error('Error loading events:', error);
				document.getElementById('errorMessage').textContent = 'Error loading events: ' + error.message;
				document.getElementById('errorMessage').style.display = 'block';
			} finally {
				if (loadingMessageEl) {
					loadingMessageEl.style.display = 'none';
				}
			}
		}

		function normalizeEventData(rawData) {
			if (!rawData) {
				return {};
			}
			if (typeof rawData === 'object') {
				return rawData;
			}
			try {
				return JSON.parse(rawData);
			} catch (_error) {
				return {};
			}
		}

		function extractClientName(eventData) {
			if (!eventData || typeof eventData !== 'object') {
				return '';
			}
			try {
				// New format: data.state.org.companyDetails.Name
				const nestedCompanyName = eventData.state
					&& eventData.state.org
					&& eventData.state.org.companyDetails
					&& typeof eventData.state.org.companyDetails.Name === 'string'
					&& eventData.state.org.companyDetails.Name.trim() !== ''
					? eventData.state.org.companyDetails.Name.trim()
					: null;

				if (nestedCompanyName) {
					return nestedCompanyName;
				}

				// Legacy format: data.companyDetails.Name
				if (eventData.companyDetails
					&& typeof eventData.companyDetails.Name === 'string'
					&& eventData.companyDetails.Name.trim() !== '') {
					return eventData.companyDetails.Name.trim();
				}
			} catch (_error) {
				// Ignore and fall through to default
			}
			return '';
		}

		function displayEvents(events) {
			const tbody = document.getElementById('logsBody');
			tbody.innerHTML = '';

			// Reset keyboard navigation for events when new events are loaded
			if (keyboardNavigationMode === 'events') {
				selectedEventIndex = -1;
			}

			events.forEach(event => {
				const levelClass = getLevelClass(event.event);
				const description = formatDescription(event);
				const descriptionPretty = formatDescriptionPretty(event);
				const eventData = normalizeEventData(event.data);
				const clientName = extractClientName(eventData);
				const dataStatus = typeof eventData.status === 'string'
					? eventData.status.toLowerCase()
					: null;
				const isToolFailure = event.event === 'tool_call' && (
					dataStatus === 'error' ||
					dataStatus === 'failed' ||
					eventData.success === false ||
					Boolean(eventData.error)
				);
				const isError = event.event === 'tool_error' || event.event === 'error' || isToolFailure;
				const statusClass = isError ? 'ko' : 'ok';
				const statusLabel = isError ? 'KO' : 'OK';

				// Main row
				const row = document.createElement('tr');
				row.className = `log-item-${levelClass}`;
				row.setAttribute('data-event-id', event.id);
				// Store event data in the row element to avoid API call when copying payload
				row.setAttribute('data-event', JSON.stringify(event));
				row.innerHTML = `
					<td style="text-align: center; padding: 2px 8px;">
						<button class="expand-btn" type="button" id="expand-btn-${event.id}" title="Expand/Collapse">
							<i class="fa-solid fa-chevron-right"></i>
						</button>
					</td>
					<td style="text-align: center; padding: 2px 8px;">
						<span class="status-indicator ${statusClass}" title="${isError ? 'Error' : 'OK'}">${statusLabel}</span>
					</td>
					<td class="log-time">${formatDate(event.timestamp)}</td>
					<td>
						<span class="level-badge ${levelClass}">
							${event.event.replace('_', ' ')}
						</span>
					</td>
					<td class="log-client">${escapeHtml(clientName)}</td>
					<td class="log-description">${description}</td>
					<td class="actions-cell">
						<button class="actions-btn" onclick="toggleActionsDropdown(event, ${event.id})" title="Actions">
							<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
								<circle cx="8" cy="3" r="1.5"/>
								<circle cx="8" cy="8" r="1.5"/>
								<circle cx="8" cy="13" r="1.5"/>
							</svg>
						</button>
						<div class="actions-dropdown" id="dropdown-${event.id}">
							<div class="actions-dropdown-item" onclick="copyEventPayload(${event.id})">
								<span>📋</span>
								<span>Copy payload</span>
							</div>
							<div class="actions-dropdown-item delete" onclick="confirmDeleteEvent(${event.id})">
								<span>🗑️</span>
								<span>Delete</span>
							</div>
						</div>
					</td>
				`;
				const expandButton = row.querySelector(`#expand-btn-${event.id}`);
				if (expandButton) {
					expandButton.addEventListener('click', (evt) => {
						evt.stopPropagation();
						toggleRowExpand(event.id);
					});
				}

				row.addEventListener('click', (evt) => {
					if (evt.target.closest('.actions-btn') || evt.target.closest('.actions-dropdown')) {
						return;
					}

					toggleRowExpand(event.id);
				});

				tbody.appendChild(row);

				// Expanded row
				const expandedRow = document.createElement('tr');
				expandedRow.className = `log-item-expanded log-item-${levelClass}`;
				expandedRow.id = `expanded-${event.id}`;

				const expandedTd = document.createElement('td');
				expandedTd.colSpan = 6;
				expandedTd.className = 'log-description-expanded';

				const pre = document.createElement('pre');
				pre.className = 'json-pretty';
				pre.textContent = descriptionPretty;

				expandedTd.appendChild(pre);
				expandedRow.appendChild(document.createElement('td')); // Empty first cell
				expandedRow.appendChild(expandedTd);
				tbody.appendChild(expandedRow);
			});
		}

		function getLevelClass(eventType) {
			const levelMap = {
				'tool_call': 'debug',
				'session_start': 'info',
				'session_end': 'info',
				'tool_error': 'error',
				'error': 'error',
				'custom': 'warning'
			};
			return levelMap[eventType] || 'info';
		}

		function getLevelIcon(eventType) {
			const iconMap = {
				'tool_call': '🐛',
				'session_start': 'ℹ️',
				'session_end': 'ℹ️',
				'tool_error': '❌',
				'error': '❌',
				'custom': '⚠️'
			};
			return iconMap[eventType] || 'ℹ️';
		}

		function formatDescription(event) {
			// Reconstruct the full payload as it was received
			const payload = {
				event: event.event,
				timestamp: event.timestamp,
				serverId: event.server_id || null,
				version: event.version || null,
				sessionId: event.session_id || null,
				userId: event.user_id || null,
				data: event.data || {}
			};

			// Remove null values to keep the JSON clean
			Object.keys(payload).forEach(key => {
				if (payload[key] === null) {
					delete payload[key];
				}
			});

			// Return as single line JSON (no indentation)
			return JSON.stringify(payload);
		}

		function formatDescriptionPretty(event) {
			// Reconstruct the full payload as it was received
			const payload = {
				event: event.event,
				timestamp: event.timestamp,
				serverId: event.server_id || null,
				version: event.version || null,
				sessionId: event.session_id || null,
				userId: event.user_id || null,
				data: event.data || {}
			};

			// Remove null values to keep the JSON clean
			Object.keys(payload).forEach(key => {
				if (payload[key] === null) {
					delete payload[key];
				}
			});

			// Return as pretty formatted JSON (with indentation)
			return JSON.stringify(payload, null, 2);
		}

		function toggleRowExpand(eventId) {
			const expandedRow = document.getElementById(`expanded-${eventId}`);
			const mainRow = document.querySelector(`tr[data-event-id="${eventId}"]`);
			const expandBtn = document.getElementById(`expand-btn-${eventId}`);

			if (expandedRow.classList.contains('expanded')) {
				// Collapse
				expandedRow.classList.remove('expanded');
				expandBtn.classList.remove('expanded');
				mainRow.classList.remove('expanded');
			} else {
				// Expand
				expandedRow.classList.add('expanded');
				expandBtn.classList.add('expanded');
				mainRow.classList.add('expanded');
			}
		}

		function formatDate(dateString) {
			if (!dateString) return '';
			const date = new Date(dateString);
			const day = date.getDate();
			const month = date.getMonth() + 1;
			const year = date.getFullYear().toString().slice(-2);
			const hours = String(date.getHours()).padStart(2, '0');
			const minutes = String(date.getMinutes()).padStart(2, '0');
			return `${day}/${month}/${year} ${hours}:${minutes}`;
		}

		function formatSize(bytes) {
			if (bytes < 1024) return bytes + ' B';
			if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
			return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
		}

		function updatePagination(data) {
			const pageInfo = document.getElementById('pageInfo');
			const currentPage = Math.floor(data.offset / data.limit) + 1;
			const totalPages = Math.ceil(data.total / data.limit);
			pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${data.total} total)`;

			document.getElementById('prevBtn').disabled = currentOffset === 0;
			document.getElementById('nextBtn').disabled = !data.hasMore;
		}

		function previousPage() {
			if (currentOffset >= limit) {
				currentOffset -= limit;
				loadEvents();
			}
		}

		function nextPage() {
			currentOffset += limit;
			loadEvents();
		}

		function refreshLogs(event) {
			if (event?.preventDefault) {
				event.preventDefault();
			}
			currentOffset = 0;
			loadEventTypeStats(selectedSession);
			loadSessions();
			loadEvents({ skipUiReset: true });
		}

		let deleteAllConfirmed = false;

		function confirmDeleteAll() {
			if (!deleteAllConfirmed) {
				deleteAllConfirmed = true;
				const confirmed = confirm('Are you sure you want to delete ALL events? This action cannot be undone.\n\nClick OK to confirm, or Cancel to abort.');
				if (!confirmed) {
					deleteAllConfirmed = false;
					return;
				}
				// Second confirmation
				const secondConfirmed = confirm('FINAL WARNING: This will permanently delete ALL events from the database.\n\nAre you absolutely sure?');
				if (!secondConfirmed) {
					deleteAllConfirmed = false;
					return;
				}
			}

			// Perform deletion
			deleteAllEvents();
		}

		async function deleteAllEvents() {
			try {
				const response = await fetch('/api/events', {
					method: 'DELETE'
				});
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;

				const data = await validResponse.json();
				alert(`Successfully deleted ${data.deletedCount || 0} events.`);

				// Reset confirmation flag
				deleteAllConfirmed = false;

				// Refresh the view
				currentOffset = 0;
				loadEventTypeStats(selectedSession);
				loadSessions();
				loadEvents();
			} catch (error) {
				console.error('Error deleting events:', error);
				alert('Error deleting events: ' + error.message);
				deleteAllConfirmed = false;
			}
		}

		function toggleNotificationMode() {
			if (notificationModeEnabled) {
				disableNotificationMode();
			} else {
				enableNotificationMode();
			}
		}

		async function enableNotificationMode() {
			if (!('Notification' in window)) {
				alert('Your browser does not support desktop notifications.');
				return;
			}

			let permission = Notification.permission;
			if (permission === 'default') {
				try {
					permission = await Notification.requestPermission();
				} catch (error) {
					console.error('Notification permission error:', error);
					permission = 'denied';
				}
			}

			if (permission !== 'granted') {
				alert('You must allow browser notifications to enable this mode.');
				return;
			}

			notificationModeEnabled = true;
			updateNotificationButtonState();
			scheduleNotificationRefresh();
		}

		function disableNotificationMode() {
			notificationModeEnabled = false;
			updateNotificationButtonState();
			clearNotificationInterval();
		}

		function updateNotificationButtonState() {
			const button = document.querySelector('.notification-toggle');
			if (!button) {
				return;
			}
			button.classList.toggle('active', notificationModeEnabled);
			button.setAttribute('title', notificationModeEnabled ? 'Disable notifications' : 'Enable notifications');
			button.innerHTML = notificationModeEnabled
				? '<i class="fa-solid fa-bell"></i>'
				: '<i class="fa-regular fa-bell"></i>';
		}

		function scheduleNotificationRefresh() {
			clearNotificationInterval();
			notificationRefreshIntervalId = setInterval(() => {
				loadEvents({ triggeredByNotification: true });
			}, NOTIFICATION_REFRESH_INTERVAL);
			loadEvents({ triggeredByNotification: true });
		}

		function clearNotificationInterval() {
			if (notificationRefreshIntervalId) {
				clearInterval(notificationRefreshIntervalId);
				notificationRefreshIntervalId = null;
			}
		}

		function handleNotificationState(events, triggeredByNotification) {
			if (!Array.isArray(events) || events.length === 0) {
				return;
			}

			const newestTimestamp = getNewestTimestampFromEvents(events);

			if (notificationModeEnabled && triggeredByNotification && lastKnownEventTimestamp) {
				const newSessionIds = events.reduce((set, event) => {
					const eventTimestamp = getEventTimestamp(event);
					const sessionId = event?.session_id;
					if (
						eventTimestamp !== null &&
						eventTimestamp > lastKnownEventTimestamp &&
						sessionId &&
						!knownSessionIds.has(sessionId)
					) {
						set.add(sessionId);
					}
					return set;
				}, new Set());

				if (newSessionIds.size > 0) {
					notifyAboutNewSessions(newSessionIds.size);
					newSessionIds.forEach((sessionId) => knownSessionIds.add(sessionId));
				}
			}

			rememberSessionsFromEvents(events);

			if (newestTimestamp !== null) {
				lastKnownEventTimestamp = Math.max(lastKnownEventTimestamp || 0, newestTimestamp);
			}
		}

		function getNewestTimestampFromEvents(events) {
			return events.reduce((latest, event) => {
				const eventTimestamp = getEventTimestamp(event);
				if (eventTimestamp === null) {
					return latest;
				}
				if (latest === null || eventTimestamp > latest) {
					return eventTimestamp;
				}
				return latest;
			}, lastKnownEventTimestamp);
		}

		function getEventTimestamp(event) {
			if (!event || !event.timestamp) {
				return null;
			}
			const timestamp = Date.parse(event.timestamp);
			return Number.isNaN(timestamp) ? null : timestamp;
		}

		function rememberSessionId(sessionId) {
			if (typeof sessionId === 'string' && sessionId.trim() !== '') {
				knownSessionIds.add(sessionId);
			}
		}

		function rememberSessionsFromList(sessionIds) {
			if (!Array.isArray(sessionIds)) {
				return;
			}
			sessionIds.forEach(rememberSessionId);
		}

		function rememberSessionsFromEvents(events) {
			if (!Array.isArray(events)) {
				return;
			}
			events.forEach(event => {
				if (event?.session_id) {
					rememberSessionId(event.session_id);
				}
			});
		}

		function notifyAboutNewSessions(newSessionsCount) {
			if (!('Notification' in window) || Notification.permission !== 'granted' || newSessionsCount <= 0) {
				return;
			}

			const title = 'New telemetry sessions';
			const body = newSessionsCount === 1
				? '1 new session started.'
				: `${newSessionsCount} new sessions started.`;

			try {
				new Notification(title, {
					body,
					tag: 'telemetry-sessions',
					renotify: true
				});
			} catch (error) {
				console.error('Error showing notification:', error);
			}
		}

		// Search with debounce
		let searchDebounceTimer;
		const searchInputEl = document.getElementById('searchInput');
		if (searchInputEl) {
			searchInputEl.addEventListener('input', (e) => {
				clearTimeout(searchDebounceTimer);
				searchDebounceTimer = setTimeout(() => {
					searchQuery = e.target.value;
					currentOffset = 0;
					loadEvents();
				}, 500);
			});
		} else {
			handleInitializationError('search input binding', new Error('Search input not found'));
		}

		// Sort order change
		const sortSelectEl = document.getElementById('sortSelect');
		if (sortSelectEl) {
			sortSelectEl.addEventListener('change', (e) => {
				sortOrder = e.target.value;
				currentOffset = 0;
				loadEvents();
			});
		} else {
			handleInitializationError('sort select binding', new Error('Sort select not found'));
		}

		// Limit change
		const limitSelectEl = document.getElementById('limitSelect');
		if (limitSelectEl) {
			limitSelectEl.addEventListener('change', (e) => {
				limit = parseInt(e.target.value);
				currentOffset = 0;
				loadEvents();
			});
		} else {
			handleInitializationError('limit select binding', new Error('Items-per-page select not found'));
		}

		// Session selection (for "All Sessions" item)
		document.querySelectorAll('[data-session="all"]').forEach(item => {
			item.addEventListener('click', () => {
				document.querySelectorAll('.server-item').forEach(i => i.classList.remove('active'));
				item.classList.add('active');
				selectedSession = 'all';
				selectedActivityDate = null; // Reset to default when selecting all sessions
				sortOrder = 'DESC';
				document.getElementById('sortSelect').value = 'DESC';
				currentOffset = 0;
				loadEvents();
				loadEventTypeStats(selectedSession);
			});
		});

		// Close dropdowns when clicking outside
		document.addEventListener('click', (e) => {
			if (!e.target.closest('.actions-cell') && !e.target.closest('.server-item-actions')) {
				document.querySelectorAll('.actions-dropdown').forEach(dropdown => {
					dropdown.classList.remove('show');
				});
				document.querySelectorAll('.server-item').forEach(item => {
					item.classList.remove('dropdown-open');
				});
			}
		});

		// Keyboard navigation state
		let keyboardNavigationMode = null; // 'sessions' or 'events'
		let selectedSessionIndex = -1;
		let selectedEventIndex = -1;

		// Remove keyboard selection from all elements
		function clearKeyboardSelection() {
			document.querySelectorAll('.server-item.keyboard-selected').forEach(item => {
				item.classList.remove('keyboard-selected');
			});
			document.querySelectorAll('.logs-table tbody tr.keyboard-selected').forEach(row => {
				row.classList.remove('keyboard-selected');
			});
		}

		// Get all session items (including "All Sessions")
		function getAllSessionItems() {
			const allSessionsItem = document.querySelector('.server-item[data-session="all"]');
			const sessionItems = Array.from(document.querySelectorAll('#sessionList .server-item'));
			return allSessionsItem ? [allSessionsItem, ...sessionItems] : sessionItems;
		}

		// Get all event rows (excluding expanded rows)
		function getAllEventRows() {
			return Array.from(document.querySelectorAll('#logsBody tr[data-event-id]')).filter(row => {
				return !row.classList.contains('log-item-expanded');
			});
		}

		// Navigate sessions with keyboard
		function navigateSessions(direction) {
			const sessions = getAllSessionItems();
			if (sessions.length === 0) return;

			clearKeyboardSelection();
			keyboardNavigationMode = 'sessions';

			if (selectedSessionIndex < 0) {
				// Find currently active session
				const activeIndex = sessions.findIndex(item => item.classList.contains('active'));
				selectedSessionIndex = activeIndex >= 0 ? activeIndex : 0;
			} else {
				if (direction === 'down') {
					selectedSessionIndex = Math.min(selectedSessionIndex + 1, sessions.length - 1);
				} else if (direction === 'up') {
					selectedSessionIndex = Math.max(selectedSessionIndex - 1, 0);
				}
			}

			const selectedItem = sessions[selectedSessionIndex];
			if (selectedItem) {
				selectedItem.classList.add('keyboard-selected');
				selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
			}
		}

		// Navigate events with keyboard
		function navigateEvents(direction) {
			const events = getAllEventRows();
			if (events.length === 0) return;

			clearKeyboardSelection();
			keyboardNavigationMode = 'events';

			if (selectedEventIndex < 0) {
				selectedEventIndex = 0;
			} else {
				if (direction === 'down') {
					selectedEventIndex = Math.min(selectedEventIndex + 1, events.length - 1);
				} else if (direction === 'up') {
					selectedEventIndex = Math.max(selectedEventIndex - 1, 0);
				}
			}

			const selectedRow = events[selectedEventIndex];
			if (selectedRow) {
				selectedRow.classList.add('keyboard-selected');
				selectedRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
			}
		}

		// Activate selected session
		function activateSelectedSession() {
			const sessions = getAllSessionItems();
			if (selectedSessionIndex >= 0 && selectedSessionIndex < sessions.length) {
				const selectedItem = sessions[selectedSessionIndex];
				selectedItem.click();
			}
		}

		// Activate selected event (expand/collapse)
		function activateSelectedEvent() {
			const events = getAllEventRows();
			if (selectedEventIndex >= 0 && selectedEventIndex < events.length) {
				const selectedRow = events[selectedEventIndex];
				const eventId = selectedRow.getAttribute('data-event-id');
				if (eventId) {
					toggleRowExpand(parseInt(eventId));
				}
			}
		}

		// Keyboard event handler
		document.addEventListener('keydown', (e) => {
			// Don't interfere with input fields or textareas
			if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
				return;
			}

			// Don't interfere with dropdowns
			if (e.target.closest('.actions-dropdown')) {
				return;
			}

			switch (e.key) {
				case 'ArrowDown':
					e.preventDefault();
					// Determine which list to navigate based on focus or current mode
					if (keyboardNavigationMode === 'sessions' || (!keyboardNavigationMode && document.activeElement.closest('.sidebar'))) {
						navigateSessions('down');
					} else {
						navigateEvents('down');
					}
					break;

				case 'ArrowUp':
					e.preventDefault();
					if (keyboardNavigationMode === 'sessions' || (!keyboardNavigationMode && document.activeElement.closest('.sidebar'))) {
						navigateSessions('up');
					} else {
						navigateEvents('up');
					}
					break;

				case 'Enter':
					e.preventDefault();
					if (keyboardNavigationMode === 'sessions') {
						activateSelectedSession();
					} else if (keyboardNavigationMode === 'events') {
						activateSelectedEvent();
					}
					break;

				case 'Escape':
					clearKeyboardSelection();
					keyboardNavigationMode = null;
					selectedSessionIndex = -1;
					selectedEventIndex = -1;
					break;
			}
		});

		// Reset keyboard navigation when clicking
		document.addEventListener('click', (e) => {
			// Don't reset if clicking on keyboard-selected items
			if (!e.target.closest('.keyboard-selected')) {
				clearKeyboardSelection();
				keyboardNavigationMode = null;
				selectedSessionIndex = -1;
				selectedEventIndex = -1;
			}
		});

		function toggleActionsDropdown(e, eventId) {
			e.stopPropagation();
			const dropdown = document.getElementById(`dropdown-${eventId}`);
			const isShowing = dropdown.classList.contains('show');
			const button = e.target.closest('.actions-btn');

			// Close all other dropdowns
			document.querySelectorAll('.actions-dropdown').forEach(d => {
				d.classList.remove('show');
			});

			// Toggle this dropdown
			if (!isShowing) {
				// Calculate position relative to the button
				if (button) {
					const rect = button.getBoundingClientRect();

					// Position dropdown to the left of the button, vertically centered
					let right = window.innerWidth - rect.left + 4;
					let top = rect.top + (rect.height / 2);

					// Ensure dropdown doesn't go off-screen
					// First, make it visible temporarily to measure its size
					dropdown.style.visibility = 'hidden';
					dropdown.style.display = 'block';
					dropdown.style.opacity = '0';
					const dropdownRect = dropdown.getBoundingClientRect();

					// Center vertically on the button
					top = top - (dropdownRect.height / 2);

					// Check if dropdown would go off the top of the screen
					if (top < 4) {
						top = 4;
					}

					// Check if dropdown would go off the bottom of the screen
					if (top + dropdownRect.height > window.innerHeight - 4) {
						top = window.innerHeight - dropdownRect.height - 4;
					}

					// Check if dropdown would go off the left edge (since it's positioned to the left)
					if (right + dropdownRect.width > window.innerWidth) {
						// If not enough space on the left, position to the right of the button instead
						right = window.innerWidth - rect.right - 4;
					}

					dropdown.style.top = `${Math.max(4, top)}px`;
					dropdown.style.right = `${Math.max(4, right)}px`;
					dropdown.style.left = 'auto';
					dropdown.style.bottom = 'auto';
					dropdown.style.visibility = 'visible';
					dropdown.style.display = 'block';
					dropdown.style.zIndex = '10000';
				}

				// Use requestAnimationFrame to ensure the element is visible before transition
				requestAnimationFrame(() => {
					dropdown.classList.add('show');
				});
			}
		}

		function toggleSessionActionsDropdown(e, sessionId) {
			e.stopPropagation();
			const dropdown = document.getElementById(`session-dropdown-${sessionId}`);
			const isShowing = dropdown.classList.contains('show');
			const serverItem = dropdown.closest('.server-item');

			// Close all other dropdowns and remove their classes
			document.querySelectorAll('.actions-dropdown').forEach(d => {
				d.classList.remove('show');
			});
			document.querySelectorAll('.server-item').forEach(item => {
				item.classList.remove('dropdown-open');
			});

			// Toggle this dropdown
			if (!isShowing) {
				dropdown.classList.add('show');
				if (serverItem) {
					serverItem.classList.add('dropdown-open');
				}
			}
		}

		async function copyEventPayload(eventId) {
			try {
				// Get event data from the DOM element (already loaded, no API call needed)
				const row = document.querySelector(`tr[data-event-id="${eventId}"]`);
				if (!row) {
					alert('Event not found');
					return;
				}

				const eventDataStr = row.getAttribute('data-event');
				if (!eventDataStr) {
					alert('Event data not available');
					return;
				}

				const event = JSON.parse(eventDataStr);

				// Reconstruct the full payload as it was received
				const payload = {
					event: event.event,
					timestamp: event.timestamp,
					serverId: event.server_id || null,
					version: event.version || null,
					sessionId: event.session_id || null,
					userId: event.user_id || null,
					data: event.data || {}
				};

				// Remove null values to keep the JSON clean
				Object.keys(payload).forEach(key => {
					if (payload[key] === null) {
						delete payload[key];
					}
				});

				// Format as beautified JSON with proper indentation (2 spaces)
				const beautifiedPayload = JSON.stringify(payload, null, 2);

				// Copy to clipboard
				await navigator.clipboard.writeText(beautifiedPayload);

				// Close dropdown
				document.querySelectorAll('.actions-dropdown').forEach(d => {
					d.classList.remove('show');
				});

				// Show feedback (optional - could use a toast notification)
				const btn = document.querySelector(`#dropdown-${eventId}`)?.previousElementSibling;
				if (btn) {
					const originalTitle = btn.getAttribute('title');
					btn.setAttribute('title', 'Payload copied to clipboard!');
					setTimeout(() => {
						btn.setAttribute('title', originalTitle || 'Actions');
					}, 2000);
				}
			} catch (error) {
				console.error('Error copying payload:', error);
				alert('Error copying payload: ' + error.message);
			}
		}

		function confirmDeleteEvent(eventId) {
			const confirmed = confirm('Are you sure you want to delete this event? This action cannot be undone.');
			if (confirmed) {
				deleteEvent(eventId);
			}
		}

		async function deleteEvent(eventId) {
			try {
				const response = await fetch(`/api/events/${eventId}`, {
					method: 'DELETE'
				});
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;

				const data = await validResponse.json();

				// Close dropdown
				document.querySelectorAll('.actions-dropdown').forEach(d => {
					d.classList.remove('show');
				});

				// Refresh the view
				loadEventTypeStats(selectedSession);
				loadSessions();
				loadEvents();
			} catch (error) {
				console.error('Error deleting event:', error);
				alert('Error deleting the event: ' + error.message);
			}
		}

		function confirmDeleteSession(sessionId) {
			const confirmed = confirm('Are you sure you want to delete all events from this session? This action cannot be undone.');
			if (confirmed) {
				deleteSession(sessionId);
			}
		}

		async function deleteSession(sessionId) {
			try {
				const response = await fetch(`/api/events?sessionId=${encodeURIComponent(sessionId)}`, {
					method: 'DELETE'
				});
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;

				const data = await validResponse.json();

				// Close dropdown
				document.querySelectorAll('.actions-dropdown').forEach(d => {
					d.classList.remove('show');
				});
				document.querySelectorAll('.server-item').forEach(item => {
					item.classList.remove('dropdown-open');
				});

				// If we were viewing this session, switch to "all"
				if (selectedSession === sessionId) {
					selectedSession = 'all';
					selectedActivityDate = null; // Reset to default when selecting all sessions
					document.querySelectorAll('.server-item').forEach(i => i.classList.remove('active'));
					const allSessionsItem = document.querySelector('[data-session="all"]');
					if (allSessionsItem) {
						allSessionsItem.classList.add('active');
					}
					sortOrder = 'DESC';
					document.getElementById('sortSelect').value = 'DESC';
				}

				// Refresh the view
				loadEventTypeStats(selectedSession);
				loadSessions();
				loadEvents();
			} catch (error) {
				console.error('Error deleting session:', error);
				alert('Error deleting the session: ' + error.message);
			}
		}

		window.addEventListener('error', (event) => {
			if (!event) {
				return;
			}
			const message = event.message || 'Unexpected runtime error';
			showGlobalError(`Runtime error: ${message}`);
		});

		window.addEventListener('unhandledrejection', (event) => {
			if (!event) {
				return;
			}
			const reason = event.reason?.message || event.reason || 'Unhandled promise rejection';
			showGlobalError(`Unhandled error: ${reason}`);
		});

		function setupSessionLegendHover() {
			const wrapper = document.querySelector('.session-activity-legend-wrapper');
			const legend = document.getElementById('sessionActivityLegend');
			if (!wrapper || !legend) {
				return;
			}

			let hoverDepth = 0;
			let closeTimeoutId = null;

			const openLegend = () => {
				if (closeTimeoutId) {
					clearTimeout(closeTimeoutId);
					closeTimeoutId = null;
				}
				wrapper.classList.add('is-open');
			};

			const scheduleClose = () => {
				if (closeTimeoutId) {
					clearTimeout(closeTimeoutId);
				}
				closeTimeoutId = setTimeout(() => {
					if (hoverDepth <= 0) {
						wrapper.classList.remove('is-open');
					}
				}, 80);
			};

			const handleEnter = () => {
				hoverDepth += 1;
				openLegend();
			};

			const handleLeave = () => {
				hoverDepth = Math.max(0, hoverDepth - 1);
				if (hoverDepth === 0) {
					scheduleClose();
				}
			};

			wrapper.addEventListener('mouseenter', handleEnter);
			wrapper.addEventListener('mouseleave', handleLeave);
			legend.addEventListener('mouseenter', handleEnter);
			legend.addEventListener('mouseleave', handleLeave);
		}

		async function loadDatabaseSize() {
			try {
				const response = await fetch('/api/database-size');
				const validResponse = await handleApiResponse(response);
				if (!validResponse) return;
				const data = await validResponse.json();
				if (data.status === 'ok') {
					const displayText = data.displayText || data.sizeFormatted;
					if (displayText) {
						const dbSizeElement = document.getElementById('dbSize');
						dbSizeElement.textContent = displayText;

						// Apply color based on percentage
						if (data.percentage !== null && data.percentage !== undefined) {
							if (data.percentage >= 80) {
								// Red for 80% or more
								dbSizeElement.style.color = 'var(--level-error)';
							} else if (data.percentage >= 70) {
								// Orange for 70% or more
								dbSizeElement.style.color = 'var(--level-warning)';
							} else {
								// Default color (inherit from parent)
								dbSizeElement.style.color = '';
							}
						}

						document.getElementById('dbSizeInfo').style.display = '';
					}
				}
			} catch (error) {
				// Silently fail if database size is not available
				console.debug('Database size not available:', error);
			}
		}

		function initializeApp() {
			runSafeInitStep('notification button state', updateNotificationButtonState);
			runSafeInitStep('theme initialization', initTheme);
			runSafeInitStep('level filters setup', setupLevelFilters);
			runSafeInitStep('sidebar resizer setup', setupSidebarResizer);
			runSafeInitStep('horizontal resizer setup', setupHorizontalResizer);
			runSafeInitStep('session legend hover', setupSessionLegendHover);
			runSafeAsyncInitStep('event type stats', () => loadEventTypeStats(selectedSession));
			runSafeAsyncInitStep('sessions list', () => loadSessions());
			runSafeAsyncInitStep('events table', () => loadEvents());
			runSafeAsyncInitStep('database size', () => loadDatabaseSize());
		}

		initializeApp();
		// Handle smooth hover animation for icon buttons group
		(function() {
			const iconButtonsGroup = document.querySelector('.icon-buttons-group');
			if (!iconButtonsGroup) return;

			let isInsideGroup = false;
			let currentHoveredButton = null;

			iconButtonsGroup.addEventListener('mouseenter', () => {
				isInsideGroup = true;
				iconButtonsGroup.classList.add('no-transition');
			});

			iconButtonsGroup.addEventListener('mouseleave', () => {
				isInsideGroup = false;
				currentHoveredButton = null;
				iconButtonsGroup.classList.remove('no-transition');
			});

			const buttons = iconButtonsGroup.querySelectorAll('.icon-btn');
			buttons.forEach((button, index) => {
				button.addEventListener('mouseenter', () => {
					if (currentHoveredButton !== null && currentHoveredButton !== index) {
						// Moving from one button to another - enable transition
						iconButtonsGroup.classList.remove('no-transition');
					} else if (currentHoveredButton === null) {
						// Entering from outside - no transition
						iconButtonsGroup.classList.add('no-transition');
					}
					currentHoveredButton = index;

					// Remove no-transition after a short delay to allow smooth transitions between buttons
					setTimeout(() => {
						if (isInsideGroup) {
							iconButtonsGroup.classList.remove('no-transition');
						}
					}, 50);
				});
			});
		})();
	</script>
</body>
</html>
